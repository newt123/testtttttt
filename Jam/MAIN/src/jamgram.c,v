head     1.21;
access   ;
symbols  ;
locks    ;comment  @@;


1.21
date     2005.01.27.09.35.41;  author p4;  state Exp;
branches ;
next     1.20;

1.20
date     2005.01.27.09.35.40;  author p4;  state Exp;
branches ;
next     1.19;

1.19
date     2005.01.27.09.35.40;  author p4;  state Exp;
branches ;
next     1.18;

1.18
date     2005.01.27.09.35.39;  author p4;  state Exp;
branches ;
next     1.17;

1.17
date     2005.01.27.09.35.38;  author p4;  state Exp;
branches ;
next     1.16;

1.16
date     2005.01.27.09.35.35;  author p4;  state Exp;
branches ;
next     1.15;

1.15
date     2005.01.27.09.35.34;  author p4;  state Exp;
branches ;
next     1.14;

1.14
date     2005.01.27.09.35.32;  author p4;  state Exp;
branches ;
next     1.13;

1.13
date     2005.01.27.09.35.31;  author p4;  state Exp;
branches ;
next     1.12;

1.12
date     2005.01.27.09.35.30;  author p4;  state Exp;
branches ;
next     1.11;

1.11
date     2005.01.27.09.35.28;  author p4;  state Exp;
branches ;
next     1.10;

1.10
date     2005.01.27.09.35.28;  author p4;  state Exp;
branches ;
next     1.9;

1.9
date     2005.01.27.09.35.28;  author p4;  state Exp;
branches ;
next     1.7;

1.7
date     2005.01.27.09.35.28;  author p4;  state Exp;
branches ;
next     1.6;

1.6
date     2005.01.27.09.35.22;  author p4;  state Exp;
branches ;
next     1.5;

1.5
date     2005.01.27.09.35.22;  author p4;  state Exp;
branches ;
next     1.4;

1.4
date     2005.01.27.09.35.18;  author p4;  state Exp;
branches ;
next     1.3;

1.3
date     2005.01.27.09.35.14;  author p4;  state Exp;
branches ;
next     1.2;

1.2
date     2005.01.27.09.35.12;  author p4;  state Exp;
branches ;
next     1.1;

1.1
date     2005.01.27.09.35.12;  author p4;  state Exp;
branches ;
next     ;


desc
@@


1.21
log
@@
text
@#ifndef lint
static char const yysccsid[] = "@@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYLEX yylex()
#define YYEMPTY -1
#define yyclearin (yychar=(YYEMPTY))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
#ifdef __cplusplus
extern "C" { char *getenv(const char *); }
#else
extern char *getenv();
extern int yylex();
extern int yyparse();
#endif
#define YYPREFIX "yy"
#line 64 "jamgram.y"
#include "jam.h"

#include "lists.h"
#include "parse.h"
#include "scan.h"
#include "compile.h"
#include "newstr.h"

# define F0 (void (*)())0
# define P0 (PARSE *)0
# define S0 (char *)0

# define pset( l,r,a ) 	  parse_make( compile_set,P0,P0,S0,S0,l,r,a )
# define pset1( l,p,a )	  parse_make( compile_settings,p,P0,S0,S0,l,L0,a )
# define pstng( p,l,r,a ) pset1( p, parse_make( F0,P0,P0,S0,S0,l,r,0 ), a )
# define prule( s,p )     parse_make( compile_rule,p,P0,s,S0,L0,L0,0 )
# define prules( l,r )	  parse_make( compile_rules,l,r,S0,S0,L0,L0,0 )
# define pfor( s,p,l )    parse_make( compile_foreach,p,P0,s,S0,l,L0,0 )
# define psetc( s,p )     parse_make( compile_setcomp,p,P0,s,S0,L0,L0,0 )
# define psete( s,l,s1,f ) parse_make( compile_setexec,P0,P0,s,s1,l,L0,f )
# define pincl( l )       parse_make( compile_include,P0,P0,S0,S0,l,L0,0 )
# define pswitch( l,p )   parse_make( compile_switch,p,P0,S0,S0,l,L0,0 )
# define plocal( l,r,p )  parse_make( compile_local,p,P0,S0,S0,l,r,0 )
# define pnull()	  parse_make( compile_null,P0,P0,S0,S0,L0,L0,0 )
# define pcases( l,r )    parse_make( F0,l,r,S0,S0,L0,L0,0 )
# define pcase( s,p )     parse_make( F0,p,P0,s,S0,L0,L0,0 )
# define pif( l,r )	  parse_make( compile_if,l,r,S0,S0,L0,L0,0 )
# define pthen( l,r )	  parse_make( F0,l,r,S0,S0,L0,L0,0 )
# define pcond( c,l,r )	  parse_make( F0,l,r,S0,S0,L0,L0,c )
# define pcomp( c,l,r )	  parse_make( F0,P0,P0,S0,S0,l,r,c )
# define plol( p,l )	  parse_make( F0,p,P0,S0,S0,l,L0,0 )


#line 61 "y.tab.c"
#define _BANG 257
#define _BANG_EQUALS 258
#define _AMPERAMPER 259
#define _LPAREN 260
#define _RPAREN 261
#define _PLUS_EQUALS 262
#define _COLON 263
#define _SEMIC 264
#define _LANGLE 265
#define _LANGLE_EQUALS 266
#define _EQUALS 267
#define _RANGLE 268
#define _RANGLE_EQUALS 269
#define _QUESTION_EQUALS 270
#define ACTIONS 271
#define BIND 272
#define CASE 273
#define DEFAULT 274
#define ELSE 275
#define EXISTING 276
#define FOR 277
#define IF 278
#define IGNORE 279
#define IN 280
#define INCLUDE 281
#define LOCAL 282
#define ON 283
#define PIECEMEAL 284
#define QUIETLY 285
#define RULE 286
#define SWITCH 287
#define TOGETHER 288
#define UPDATED 289
#define _LBRACE 290
#define _BARBAR 291
#define _RBRACE 292
#define ARG 293
#define STRING 294
#define YYERRCODE 256
const short yylhs[] = {                                        -1,
    0,    1,    1,    1,    1,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    2,   11,   12,    2,    6,
    6,    6,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    7,    7,   13,    4,    4,    3,
   14,   14,    5,    9,    9,   15,   15,   15,   15,   15,
   15,   10,   10,
};
const short yylen[] = {                                         2,
    1,    0,    2,    4,    6,    3,    3,    3,    4,    6,
    5,    7,    5,    5,    7,    3,    0,    0,    9,    1,
    1,    1,    1,    3,    3,    3,    3,    3,    3,    3,
    2,    3,    3,    3,    0,    2,    4,    1,    3,    1,
    0,    2,    1,    0,    2,    1,    1,    1,    1,    1,
    1,    0,    2,
};
const short yydefred[] = {                                      0,
   44,    0,    0,   41,   41,    0,   41,    0,    0,    0,
    1,    0,    0,    0,    0,    0,    0,   43,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    3,   21,
   20,   22,    0,   41,   41,   51,   48,   50,   49,   47,
   46,    0,   45,   41,   31,    0,    0,    0,    0,    0,
    0,    0,   41,    0,    0,    0,    7,   42,    0,   41,
   16,    0,    6,   41,    8,   41,    0,    0,   41,    0,
    0,   34,   25,   26,   27,   24,   28,   29,   30,   32,
    0,    0,    4,    0,    0,    0,    0,   39,    0,   41,
    9,   53,   17,    0,    0,    0,    0,   13,   36,   11,
    0,    0,    0,    0,    5,    0,   10,   18,   12,   15,
   37,    0,   19,
};
const short yydgoto[] = {                                      10,
   11,   12,   27,   28,   13,   35,   86,   20,   14,   70,
  102,  112,   87,   22,   43,
};
const short yysindex[] = {                                   -182,
    0, -274, -252,    0,    0, -270,    0, -182,    0,    0,
    0, -182, -160, -152, -245, -252, -252,    0, -238, -237,
 -225, -250, -177, -165, -224, -240, -196, -189,    0,    0,
    0,    0, -191,    0,    0,    0,    0,    0,    0,    0,
    0, -187,    0,    0,    0, -227, -210, -210, -210, -210,
 -210, -210,    0, -252, -182, -252,    0,    0, -182,    0,
    0, -192,    0,    0,    0,    0, -136, -173,    0, -193,
 -181,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -198, -158,    0, -149, -176, -174, -192,    0, -145,    0,
    0,    0,    0, -182, -155, -182, -134,    0,    0,    0,
 -129, -164, -154, -165,    0, -182,    0,    0,    0,    0,
    0, -153,    0,
};
const short yyrindex[] = {                                    140,
    0,    0,    0,    0,    0,    0,    0, -150, -190,    0,
    0,    3,    0,    0,    0,    0,    0,    0, -221,    0,
    0, -246,    0,    0,    0,    0, -121,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -146,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0, -150,    0,    0,    0,    3,    0,
    0, -147,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -212,    0,    0,    0,    0, -147,    0,    0,    0,
    0,    0,    0, -150,    1,    3,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -259,    0,    0,    0,    0,
    0,    0,    0,
};
const short yygindex[] = {                                      0,
   -8,  -22,    2,   82,    9,   80,   61,   -6,    0,    0,
    0,    0,    0,    0,    0,
};
#define YYTABLESIZE 295
const short yytable[] = {                                      26,
   14,   61,    2,   29,   16,   21,   23,   17,   25,   45,
   46,   19,   40,    2,   40,   40,   40,   40,   15,   47,
   40,   54,   24,   40,   19,   19,   48,   49,   50,   51,
   52,   54,    2,   72,   44,   67,   68,   23,   57,   23,
   18,   53,   58,   40,   40,   71,   81,   80,   33,   82,
   83,   63,   55,   56,   79,   73,   74,   75,   76,   77,
   78,   84,   19,   56,   19,   62,   64,   89,   23,   23,
   92,   43,   41,   41,   65,   66,   43,   33,   33,   43,
   85,  110,   18,   43,   69,  103,   59,  105,    1,   60,
   91,  101,   43,   95,    2,    3,   93,  111,    4,    5,
   54,   30,   41,    6,    7,    1,   31,    8,   94,   32,
    9,    2,    3,   33,   96,    4,   97,   98,  100,  104,
    6,    7,   34,   36,    8,   30,   37,    9,  106,  108,
   31,   38,   39,   32,  107,   40,   41,  109,  113,    2,
   42,    2,   38,   52,   35,   88,   90,   99,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   14,    0,   14,    0,    2,    0,   14,   14,    0,
    0,   14,   14,    0,    0,    0,   14,   14,    0,    0,
   14,    0,   14,   14,    2,
};
const short yycheck[] = {                                       8,
    0,   24,    0,   12,  257,    4,    5,  260,    7,   16,
   17,    3,  259,  273,  261,  262,  263,  264,  293,  258,
  267,  259,  293,  270,   16,   17,  265,  266,  267,  268,
  269,  259,  292,  261,  280,   34,   35,  259,  264,  261,
  293,  280,  293,  290,  291,   44,   55,   54,  261,   56,
   59,  292,  290,  291,   53,   47,   48,   49,   50,   51,
   52,   60,   54,  291,   56,  290,  263,   66,  290,  291,
   69,  262,  263,  264,  264,  267,  267,  290,  291,  270,
  273,  104,  293,  274,  272,   94,  264,   96,  271,  267,
  264,   90,  283,  292,  277,  278,  290,  106,  281,  282,
  259,  262,  293,  286,  287,  271,  267,  290,  290,  270,
  293,  277,  278,  274,  264,  281,  293,  292,  264,  275,
  286,  287,  283,  276,  290,  262,  279,  293,  263,  294,
  267,  284,  285,  270,  264,  288,  289,  292,  292,    0,
  293,  292,  264,  290,  292,   64,   67,   87,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  271,   -1,  273,   -1,  273,   -1,  277,  278,   -1,
   -1,  281,  282,   -1,   -1,   -1,  286,  287,   -1,   -1,
  290,   -1,  292,  293,  292,
};
#define YYFINAL 10
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 294
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_BANG","_BANG_EQUALS",
"_AMPERAMPER","_LPAREN","_RPAREN","_PLUS_EQUALS","_COLON","_SEMIC","_LANGLE",
"_LANGLE_EQUALS","_EQUALS","_RANGLE","_RANGLE_EQUALS","_QUESTION_EQUALS",
"ACTIONS","BIND","CASE","DEFAULT","ELSE","EXISTING","FOR","IF","IGNORE","IN",
"INCLUDE","LOCAL","ON","PIECEMEAL","QUIETLY","RULE","SWITCH","TOGETHER",
"UPDATED","_LBRACE","_BARBAR","_RBRACE","ARG","STRING",
};
const char * const yyrule[] = {
"$accept : run",
"run : block",
"block :",
"block : rule block",
"block : LOCAL args _SEMIC block",
"block : LOCAL args _EQUALS args _SEMIC block",
"rule : _LBRACE block _RBRACE",
"rule : INCLUDE args _SEMIC",
"rule : ARG lol _SEMIC",
"rule : arg1 assign args _SEMIC",
"rule : arg1 ON args assign args _SEMIC",
"rule : arg1 DEFAULT _EQUALS args _SEMIC",
"rule : FOR ARG IN args _LBRACE block _RBRACE",
"rule : SWITCH args _LBRACE cases _RBRACE",
"rule : IF cond _LBRACE block _RBRACE",
"rule : IF cond _LBRACE block _RBRACE ELSE rule",
"rule : RULE ARG rule",
"$$1 :",
"$$2 :",
"rule : ACTIONS eflags ARG bindlist _LBRACE $$1 STRING $$2 _RBRACE",
"assign : _EQUALS",
"assign : _PLUS_EQUALS",
"assign : _QUESTION_EQUALS",
"cond : arg1",
"cond : arg1 _EQUALS arg1",
"cond : arg1 _BANG_EQUALS arg1",
"cond : arg1 _LANGLE arg1",
"cond : arg1 _LANGLE_EQUALS arg1",
"cond : arg1 _RANGLE arg1",
"cond : arg1 _RANGLE_EQUALS arg1",
"cond : arg1 IN args",
"cond : _BANG cond",
"cond : cond _AMPERAMPER cond",
"cond : cond _BARBAR cond",
"cond : _LPAREN cond _RPAREN",
"cases :",
"cases : case cases",
"case : CASE ARG _COLON block",
"lol : args",
"lol : args _COLON lol",
"args : argsany",
"argsany :",
"argsany : argsany ARG",
"arg1 : ARG",
"eflags :",
"eflags : eflags eflag",
"eflag : UPDATED",
"eflag : TOGETHER",
"eflag : IGNORE",
"eflag : QUIETLY",
"eflag : PIECEMEAL",
"eflag : EXISTING",
"bindlist :",
"bindlist : BIND args",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab

int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if ((yys = getenv("YYDEBUG")))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if ((yyn = yydefred[yystate])) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#if defined(lint) || defined(__GNUC__)
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#if defined(lint) || defined(__GNUC__)
    goto yyerrlab;
#endif
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 102 "jamgram.y"
{ 
		    if( yyvsp[0].parse->func == compile_null )
		    {
			parse_free( yyvsp[0].parse );
		    }
		    else
		    {
			parse_save( yyvsp[0].parse ); 
		    }
		}
break;
case 2:
#line 120 "jamgram.y"
{ yyval.parse = pnull(); }
break;
case 3:
#line 122 "jamgram.y"
{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
break;
case 4:
#line 124 "jamgram.y"
{ yyval.parse = plocal( yyvsp[-2].list, L0, yyvsp[0].parse ); }
break;
case 5:
#line 126 "jamgram.y"
{ yyval.parse = plocal( yyvsp[-4].list, yyvsp[-2].list, yyvsp[0].parse ); }
break;
case 6:
#line 130 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
break;
case 7:
#line 132 "jamgram.y"
{ yyval.parse = pincl( yyvsp[-1].list ); }
break;
case 8:
#line 134 "jamgram.y"
{ yyval.parse = prule( yyvsp[-2].string, yyvsp[-1].parse ); }
break;
case 9:
#line 136 "jamgram.y"
{ yyval.parse = pset( yyvsp[-3].list, yyvsp[-1].list, yyvsp[-2].number ); }
break;
case 10:
#line 138 "jamgram.y"
{ yyval.parse = pstng( yyvsp[-3].list, yyvsp[-5].list, yyvsp[-1].list, yyvsp[-2].number ); }
break;
case 11:
#line 140 "jamgram.y"
{ yyval.parse = pset( yyvsp[-4].list, yyvsp[-1].list, ASSIGN_DEFAULT ); }
break;
case 12:
#line 142 "jamgram.y"
{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-1].parse, yyvsp[-3].list ); }
break;
case 13:
#line 144 "jamgram.y"
{ yyval.parse = pswitch( yyvsp[-3].list, yyvsp[-1].parse ); }
break;
case 14:
#line 146 "jamgram.y"
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, pnull() ) ); }
break;
case 15:
#line 148 "jamgram.y"
{ yyval.parse = pif( yyvsp[-5].parse, pthen( yyvsp[-3].parse, yyvsp[0].parse ) ); }
break;
case 16:
#line 150 "jamgram.y"
{ yyval.parse = psetc( yyvsp[-1].string, yyvsp[0].parse ); }
break;
case 17:
#line 152 "jamgram.y"
{ yymode( SCAN_STRING ); }
break;
case 18:
#line 154 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
break;
case 19:
#line 156 "jamgram.y"
{ yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].list,yyvsp[-2].string,yyvsp[-7].number ); }
break;
case 20:
#line 164 "jamgram.y"
{ yyval.number = ASSIGN_SET; }
break;
case 21:
#line 166 "jamgram.y"
{ yyval.number = ASSIGN_APPEND; }
break;
case 22:
#line 168 "jamgram.y"
{ yyval.number = ASSIGN_DEFAULT; }
break;
case 23:
#line 176 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yyvsp[0].list, L0 ); }
break;
case 24:
#line 178 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 25:
#line 180 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 26:
#line 182 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 27:
#line 184 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 28:
#line 186 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 29:
#line 188 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 30:
#line 190 "jamgram.y"
{ yyval.parse = pcomp( COND_IN, yyvsp[-2].list, yyvsp[0].list ); }
break;
case 31:
#line 192 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yyvsp[0].parse, P0 ); }
break;
case 32:
#line 194 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
break;
case 33:
#line 196 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
break;
case 34:
#line 198 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
break;
case 35:
#line 209 "jamgram.y"
{ yyval.parse = P0; }
break;
case 36:
#line 211 "jamgram.y"
{ yyval.parse = pcases( yyvsp[-1].parse, yyvsp[0].parse ); }
break;
case 37:
#line 215 "jamgram.y"
{ yyval.parse = pcase( yyvsp[-2].string, yyvsp[0].parse ); }
break;
case 38:
#line 223 "jamgram.y"
{ yyval.parse = plol( P0, yyvsp[0].list ); }
break;
case 39:
#line 225 "jamgram.y"
{ yyval.parse = plol( yyvsp[0].parse, yyvsp[-2].list ); }
break;
case 40:
#line 234 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
break;
case 41:
#line 238 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); }
break;
case 42:
#line 240 "jamgram.y"
{ yyval.list = list_new( yyvsp[-1].list, copystr( yyvsp[0].string ) ); }
break;
case 43:
#line 244 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yyvsp[0].string ) ); }
break;
case 44:
#line 253 "jamgram.y"
{ yyval.number = 0; }
break;
case 45:
#line 255 "jamgram.y"
{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
break;
case 46:
#line 259 "jamgram.y"
{ yyval.number = EXEC_UPDATED; }
break;
case 47:
#line 261 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; }
break;
case 48:
#line 263 "jamgram.y"
{ yyval.number = EXEC_IGNORE; }
break;
case 49:
#line 265 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; }
break;
case 50:
#line 267 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; }
break;
case 51:
#line 269 "jamgram.y"
{ yyval.number = EXEC_EXISTING; }
break;
case 52:
#line 278 "jamgram.y"
{ yyval.list = L0; }
break;
case 53:
#line 280 "jamgram.y"
{ yyval.list = yyvsp[0].list; }
break;
#line 695 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
@


1.20
log
@@
text
@a478 1
			parse_save( P0 );
d487 1
a487 1
#line 121 "jamgram.y"
d491 1
a491 1
#line 123 "jamgram.y"
d495 1
a495 1
#line 125 "jamgram.y"
d499 1
a499 1
#line 127 "jamgram.y"
d503 1
a503 1
#line 131 "jamgram.y"
d507 1
a507 1
#line 133 "jamgram.y"
d511 1
a511 1
#line 135 "jamgram.y"
d515 1
a515 1
#line 137 "jamgram.y"
d519 1
a519 1
#line 139 "jamgram.y"
d523 1
a523 1
#line 141 "jamgram.y"
d527 1
a527 1
#line 143 "jamgram.y"
d531 1
a531 1
#line 145 "jamgram.y"
d535 1
a535 1
#line 147 "jamgram.y"
d539 1
a539 1
#line 149 "jamgram.y"
d543 1
a543 1
#line 151 "jamgram.y"
d547 1
a547 1
#line 153 "jamgram.y"
d551 1
a551 1
#line 155 "jamgram.y"
d555 1
a555 1
#line 157 "jamgram.y"
d559 1
a559 1
#line 165 "jamgram.y"
d563 1
a563 1
#line 167 "jamgram.y"
d567 1
a567 1
#line 169 "jamgram.y"
d571 1
a571 1
#line 177 "jamgram.y"
d575 1
a575 1
#line 179 "jamgram.y"
d579 1
a579 1
#line 181 "jamgram.y"
d583 1
a583 1
#line 183 "jamgram.y"
d587 1
a587 1
#line 185 "jamgram.y"
d591 1
a591 1
#line 187 "jamgram.y"
d595 1
a595 1
#line 189 "jamgram.y"
d599 1
a599 1
#line 191 "jamgram.y"
d603 1
a603 1
#line 193 "jamgram.y"
d607 1
a607 1
#line 195 "jamgram.y"
d611 1
a611 1
#line 197 "jamgram.y"
d615 1
a615 1
#line 199 "jamgram.y"
d619 1
a619 1
#line 210 "jamgram.y"
d623 1
a623 1
#line 212 "jamgram.y"
d627 1
a627 1
#line 216 "jamgram.y"
d631 1
a631 1
#line 224 "jamgram.y"
d635 1
a635 1
#line 226 "jamgram.y"
d639 1
a639 1
#line 235 "jamgram.y"
d643 1
a643 1
#line 239 "jamgram.y"
d647 1
a647 1
#line 241 "jamgram.y"
d651 1
a651 1
#line 245 "jamgram.y"
d655 1
a655 1
#line 254 "jamgram.y"
d659 1
a659 1
#line 256 "jamgram.y"
d663 1
a663 1
#line 260 "jamgram.y"
d667 1
a667 1
#line 262 "jamgram.y"
d671 1
a671 1
#line 264 "jamgram.y"
d675 1
a675 1
#line 266 "jamgram.y"
d679 1
a679 1
#line 268 "jamgram.y"
d683 1
a683 1
#line 270 "jamgram.y"
d687 1
a687 1
#line 279 "jamgram.y"
d691 1
a691 1
#line 281 "jamgram.y"
d694 1
a694 1
#line 696 "y.tab.c"
@


1.19
log
@@
text
@d49 2
a50 1
# define plocal( l,r,p )  parse_make( compile_local,p,P0,S0,S0,l,r,0 );
d60 1
a60 1
#line 60 "y.tab.c"
d474 12
a485 2
#line 101 "jamgram.y"
{ parse_save( yyvsp[0].parse ); }
d488 2
a489 2
#line 110 "jamgram.y"
{ yyval.parse = 0; }
d492 1
a492 1
#line 112 "jamgram.y"
d496 1
a496 1
#line 114 "jamgram.y"
d500 1
a500 1
#line 116 "jamgram.y"
d504 1
a504 1
#line 120 "jamgram.y"
d508 1
a508 1
#line 122 "jamgram.y"
d512 1
a512 1
#line 124 "jamgram.y"
d516 1
a516 1
#line 126 "jamgram.y"
d520 1
a520 1
#line 128 "jamgram.y"
d524 1
a524 1
#line 130 "jamgram.y"
d528 1
a528 1
#line 132 "jamgram.y"
d532 1
a532 1
#line 134 "jamgram.y"
d536 2
a537 2
#line 136 "jamgram.y"
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, P0 ) ); }
d540 1
a540 1
#line 138 "jamgram.y"
d544 1
a544 1
#line 140 "jamgram.y"
d548 1
a548 1
#line 142 "jamgram.y"
d552 1
a552 1
#line 144 "jamgram.y"
d556 1
a556 1
#line 146 "jamgram.y"
d560 1
a560 1
#line 154 "jamgram.y"
d564 1
a564 1
#line 156 "jamgram.y"
d568 1
a568 1
#line 158 "jamgram.y"
d572 1
a572 1
#line 166 "jamgram.y"
d576 1
a576 1
#line 168 "jamgram.y"
d580 1
a580 1
#line 170 "jamgram.y"
d584 1
a584 1
#line 172 "jamgram.y"
d588 1
a588 1
#line 174 "jamgram.y"
d592 1
a592 1
#line 176 "jamgram.y"
d596 1
a596 1
#line 178 "jamgram.y"
d600 1
a600 1
#line 180 "jamgram.y"
d604 1
a604 1
#line 182 "jamgram.y"
d608 1
a608 1
#line 184 "jamgram.y"
d612 1
a612 1
#line 186 "jamgram.y"
d616 1
a616 1
#line 188 "jamgram.y"
d620 1
a620 1
#line 199 "jamgram.y"
d624 1
a624 1
#line 201 "jamgram.y"
d628 1
a628 1
#line 205 "jamgram.y"
d632 1
a632 1
#line 213 "jamgram.y"
d636 1
a636 1
#line 215 "jamgram.y"
d640 1
a640 1
#line 224 "jamgram.y"
d644 1
a644 1
#line 228 "jamgram.y"
d648 1
a648 1
#line 230 "jamgram.y"
d652 1
a652 1
#line 234 "jamgram.y"
d656 1
a656 1
#line 243 "jamgram.y"
d660 1
a660 1
#line 245 "jamgram.y"
d664 1
a664 1
#line 249 "jamgram.y"
d668 1
a668 1
#line 251 "jamgram.y"
d672 1
a672 1
#line 253 "jamgram.y"
d676 1
a676 1
#line 255 "jamgram.y"
d680 1
a680 1
#line 257 "jamgram.y"
d684 1
a684 1
#line 259 "jamgram.y"
d688 1
a688 1
#line 268 "jamgram.y"
d692 1
a692 1
#line 270 "jamgram.y"
d695 1
a695 1
#line 685 "y.tab.c"
@


1.18
log
@@
text
@d49 1
a49 1
# define plocal( l,p )	  parse_make( compile_local,p,P0,S0,S0,l,L0,0 );
d100 6
a105 6
    0,    1,    1,    1,    2,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,   11,   12,    2,    6,    6,
    6,    8,    8,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    7,    7,   13,    4,    4,    3,   14,
   14,    5,    9,    9,   15,   15,   15,   15,   15,   15,
   10,   10,
d108 6
a113 6
    1,    0,    2,    4,    3,    3,    3,    4,    6,    5,
    7,    5,    5,    7,    3,    0,    0,    9,    1,    1,
    1,    1,    3,    3,    3,    3,    3,    3,    3,    2,
    3,    3,    3,    0,    2,    4,    1,    3,    1,    0,
    2,    1,    0,    2,    1,    1,    1,    1,    1,    1,
    0,    2,
d116 12
a127 11
   43,    0,    0,   40,   40,    0,   40,    0,    0,    0,
    1,    0,    0,    0,    0,    0,    0,   42,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    3,   20,
   19,   21,    0,   40,   40,   50,   47,   49,   48,   46,
   45,    0,   44,   40,   30,    0,    0,    0,    0,    0,
    0,    0,   40,    0,    0,    0,    6,   41,    0,   15,
    0,    5,   40,    7,   40,    0,    0,   40,    0,    0,
   33,   24,   25,   26,   23,   27,   28,   29,   31,    0,
    0,    4,    0,    0,    0,   38,    0,   40,    8,   52,
   16,    0,    0,    0,   12,   35,   10,    0,    0,    0,
    0,    0,    9,   17,   11,   14,   36,    0,   18,
d130 2
a131 2
   11,   12,   27,   28,   13,   35,   84,   20,   14,   69,
   99,  108,   85,   22,   43,
d133 13
a145 12
const short yysindex[] = {                                   -189,
    0, -274, -252,    0,    0, -273,    0, -189,    0,    0,
    0, -189, -167, -145, -253, -252, -252,    0, -139, -237,
 -235, -258, -230, -169, -247, -254, -214, -212,    0,    0,
    0,    0, -203,    0,    0,    0,    0,    0,    0,    0,
    0, -206,    0,    0,    0, -229, -220, -220, -220, -220,
 -220, -220,    0, -252, -189, -252,    0,    0, -189,    0,
 -199,    0,    0,    0,    0, -239, -186,    0, -209, -205,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -201,
 -173,    0, -194, -182, -199,    0, -159,    0,    0,    0,
    0, -189, -164, -150,    0,    0,    0, -149, -180, -172,
 -169, -189,    0,    0,    0,    0,    0, -170,    0,
d147 4
a150 4
const short yyrindex[] = {                                    123,
    0,    0,    0,    0,    0,    0,    0, -160, -187,    0,
    0,    3,    0,    0,    0,    0,    0,    0, -219,    0,
    0, -246,    0,    0,    0,    0, -131,    0,    0,    0,
d152 3
a154 3
    0, -165,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0, -160,    0,    0,    0,    3,    0,
 -157,    0,    0,    0,    0,    0,    0,    0,    0,    0,
d156 4
a159 3
 -222,    0,    0,    0, -157,    0,    0,    0,    0,    0,
    0, -160,    1,    0,    0,    0,    0,    0,    0,    0,
    0, -259,    0,    0,    0,    0,    0,    0,    0,
d162 1
a162 1
   -8,  -22,    2,   73,    9,   71,   53,   -6,    0,    0,
d167 15
a181 15
   13,   60,    2,   29,   16,   21,   23,   17,   25,   45,
   46,   19,   39,    2,   39,   39,   39,   39,   15,   24,
   39,   54,   30,   39,   19,   19,   44,   31,   57,   54,
   32,   71,    2,   59,   58,   66,   67,   62,   32,   22,
   18,   22,   61,   39,   39,   70,   80,   79,   63,   81,
   82,   64,   55,   56,   78,   72,   73,   74,   75,   76,
   77,   56,   19,   65,   19,   68,   87,   32,   32,   90,
   22,   22,   18,   83,   42,   40,   40,   89,  106,   42,
   91,    1,   42,  100,   92,   54,   42,    2,    3,   98,
   93,    4,    5,  107,   30,   42,    6,    7,   94,   31,
    8,    1,   32,    9,   97,   40,   33,    2,    3,   95,
  101,    4,  102,  104,  103,   34,    6,    7,   47,  105,
    8,  109,    2,    9,   51,   48,   49,   50,   51,   52,
   36,    2,   37,   37,   34,   86,   88,   96,   38,   39,
   53,    0,   40,   41,    0,    0,    0,   42,    0,    0,
d194 3
a196 3
    0,   13,    0,   13,    0,    2,    0,   13,   13,    0,
    0,   13,   13,    0,    0,    0,   13,   13,    0,    0,
   13,    0,   13,   13,    2,
d200 14
a213 14
   17,    3,  259,  273,  261,  262,  263,  264,  293,  293,
  267,  259,  262,  270,   16,   17,  280,  267,  264,  259,
  270,  261,  292,  264,  293,   34,   35,  292,  261,  259,
  293,  261,  290,  290,  291,   44,   55,   54,  263,   56,
   59,  264,  290,  291,   53,   47,   48,   49,   50,   51,
   52,  291,   54,  267,   56,  272,   65,  290,  291,   68,
  290,  291,  293,  273,  262,  263,  264,  264,  101,  267,
  290,  271,  270,   92,  290,  259,  274,  277,  278,   88,
  292,  281,  282,  102,  262,  283,  286,  287,  293,  267,
  290,  271,  270,  293,  264,  293,  274,  277,  278,  292,
  275,  281,  263,  294,  264,  283,  286,  287,  258,  292,
  290,  292,    0,  293,  290,  265,  266,  267,  268,  269,
  276,  292,  264,  279,  292,   63,   66,   85,  284,  285,
  280,   -1,  288,  289,   -1,   -1,   -1,  293,   -1,   -1,
d256 1
d486 1
a486 1
{ yyval.parse = plocal( yyvsp[-2].list, yyvsp[0].parse ); }
d489 2
a490 2
#line 118 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
d494 1
a494 1
{ yyval.parse = pincl( yyvsp[-1].list ); }
d498 1
a498 1
{ yyval.parse = prule( yyvsp[-2].string, yyvsp[-1].parse ); }
d502 1
a502 1
{ yyval.parse = pset( yyvsp[-3].list, yyvsp[-1].list, yyvsp[-2].number ); }
d506 1
a506 1
{ yyval.parse = pstng( yyvsp[-3].list, yyvsp[-5].list, yyvsp[-1].list, yyvsp[-2].number ); }
d510 1
a510 1
{ yyval.parse = pset( yyvsp[-4].list, yyvsp[-1].list, ASSIGN_DEFAULT ); }
d514 1
a514 1
{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-1].parse, yyvsp[-3].list ); }
d518 1
a518 1
{ yyval.parse = pswitch( yyvsp[-3].list, yyvsp[-1].parse ); }
d522 1
a522 1
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, P0 ) ); }
d526 1
a526 1
{ yyval.parse = pif( yyvsp[-5].parse, pthen( yyvsp[-3].parse, yyvsp[0].parse ) ); }
d530 1
a530 1
{ yyval.parse = psetc( yyvsp[-1].string, yyvsp[0].parse ); }
d534 1
a534 1
{ yymode( SCAN_STRING ); }
d538 1
a538 1
{ yymode( SCAN_NORMAL ); }
d542 1
a542 1
{ yyval.parse = psete( yyvsp[-6].string,yyvsp[-5].list,yyvsp[-2].string,yyvsp[-7].number ); }
d545 2
a546 2
#line 152 "jamgram.y"
{ yyval.number = ASSIGN_SET; }
d550 1
a550 1
{ yyval.number = ASSIGN_APPEND; }
d554 1
a554 1
{ yyval.number = ASSIGN_DEFAULT; }
d557 2
a558 2
#line 164 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yyvsp[0].list, L0 ); }
d562 1
a562 1
{ yyval.parse = pcomp( COND_EQUALS, yyvsp[-2].list, yyvsp[0].list ); }
d566 1
a566 1
{ yyval.parse = pcomp( COND_NOTEQ, yyvsp[-2].list, yyvsp[0].list ); }
d570 1
a570 1
{ yyval.parse = pcomp( COND_LESS, yyvsp[-2].list, yyvsp[0].list ); }
d574 1
a574 1
{ yyval.parse = pcomp( COND_LESSEQ, yyvsp[-2].list, yyvsp[0].list ); }
d578 1
a578 1
{ yyval.parse = pcomp( COND_MORE, yyvsp[-2].list, yyvsp[0].list ); }
d582 1
a582 1
{ yyval.parse = pcomp( COND_MOREEQ, yyvsp[-2].list, yyvsp[0].list ); }
d586 1
a586 1
{ yyval.parse = pcomp( COND_IN, yyvsp[-2].list, yyvsp[0].list ); }
d590 1
a590 1
{ yyval.parse = pcond( COND_NOT, yyvsp[0].parse, P0 ); }
d594 1
a594 1
{ yyval.parse = pcond( COND_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
d598 1
a598 1
{ yyval.parse = pcond( COND_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
d602 1
a602 1
{ yyval.parse = yyvsp[-1].parse; }
d605 2
a606 2
#line 197 "jamgram.y"
{ yyval.parse = P0; }
d610 1
a610 1
{ yyval.parse = pcases( yyvsp[-1].parse, yyvsp[0].parse ); }
d613 2
a614 2
#line 203 "jamgram.y"
{ yyval.parse = pcase( yyvsp[-2].string, yyvsp[0].parse ); }
d617 2
a618 2
#line 211 "jamgram.y"
{ yyval.parse = plol( P0, yyvsp[0].list ); }
d622 1
a622 1
{ yyval.parse = plol( yyvsp[0].parse, yyvsp[-2].list ); }
d625 2
a626 2
#line 222 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
d629 2
a630 2
#line 226 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); }
d634 1
a634 1
{ yyval.list = list_new( yyvsp[-1].list, copystr( yyvsp[0].string ) ); }
d637 2
a638 2
#line 232 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yyvsp[0].string ) ); }
d641 2
a642 2
#line 241 "jamgram.y"
{ yyval.number = 0; }
d646 1
a646 1
{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
d649 2
a650 2
#line 247 "jamgram.y"
{ yyval.number = EXEC_UPDATED; }
d654 1
a654 1
{ yyval.number = EXEC_TOGETHER; }
d658 1
a658 1
{ yyval.number = EXEC_IGNORE; }
d662 1
a662 1
{ yyval.number = EXEC_QUIETLY; }
d666 1
a666 1
{ yyval.number = EXEC_PIECEMEAL; }
d670 1
a670 1
{ yyval.number = EXEC_EXISTING; }
d673 2
a674 2
#line 266 "jamgram.y"
{ yyval.list = L0; }
d678 4
d684 1
a684 1
#line 677 "y.tab.c"
@


1.17
log
@@
text
@d100 6
a105 6
    0,    1,    1,    1,    2,    2,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    4,   12,   13,    4,
    7,    7,    7,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    9,    8,    8,   14,    5,    5,
    3,   15,   15,    6,   10,   10,   16,   16,   16,   16,
   16,   16,   11,   11,
d108 6
a113 6
    1,    0,    1,    4,    1,    2,    3,    3,    3,    4,
    6,    5,    7,    5,    5,    7,    3,    0,    0,    9,
    1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
    3,    2,    3,    3,    3,    0,    2,    4,    1,    3,
    1,    0,    2,    1,    0,    2,    1,    1,    1,    1,
    1,    1,    0,    2,
d116 11
a126 11
   45,    0,    0,   42,   42,    0,   42,    0,    0,    0,
    1,    0,    5,    0,    0,    0,    0,    0,   44,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    6,
   22,   21,   23,    0,   42,   42,   52,   49,   51,   50,
   48,   47,    0,   46,   42,   32,    0,    0,    0,    0,
    0,    0,    0,   42,    0,    0,    0,    8,   43,    0,
   17,    0,    7,   42,    9,   42,    0,    0,   42,    0,
    0,   35,   26,   27,   28,   25,   29,   30,   31,   33,
    0,    0,    4,    0,    0,    0,   40,    0,   42,   10,
   54,   18,    0,    0,    0,   14,   37,   12,    0,    0,
    0,    0,    0,   11,   19,   13,   16,   38,    0,   20,
d129 2
a130 2
   11,   12,   28,   13,   29,   14,   36,   85,   21,   15,
   70,  100,  109,   86,   23,   44,
d132 12
a143 12
const short yysindex[] = {                                   -172,
    0, -276, -252,    0,    0, -274,    0, -172,    0,    0,
    0, -155,    0, -150, -142, -259, -252, -252,    0, -235,
 -248, -239, -265, -228, -155, -261, -246, -219, -209,    0,
    0,    0,    0, -204,    0,    0,    0,    0,    0,    0,
    0,    0, -207,    0,    0,    0, -237, -226, -226, -226,
 -226, -226, -226,    0, -252, -172, -252,    0,    0, -172,
    0, -197,    0,    0,    0,    0, -174, -195,    0, -213,
 -211,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -212, -173,    0, -196, -203, -197,    0, -166,    0,    0,
    0,    0, -172, -175, -159,    0,    0,    0, -157, -186,
 -181, -155, -172,    0,    0,    0,    0,    0, -167,    0,
d145 4
a148 4
const short yyrindex[] = {                                    119,
    0,    0,    0,    0,    0,    0,    0, -165, -180,    0,
    0,    3,    0,    0,    0,    0,    0,    0,    0, -241,
    0,    0, -189,    0,    0,    0,    0, -136,    0,    0,
d150 3
a152 3
    0,    0, -161,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -165,    0,    0,    0,    4,
    0, -162,    0,    0,    0,    0,    0,    0,    0,    0,
d154 3
a156 3
    0, -251,    0,    0,    0, -162,    0,    0,    0,    0,
    0,    0, -165,    1,    0,    0,    0,    0,    0,    0,
    0,    0, -257,    0,    0,    0,    0,    0,    0,    0,
d159 2
a160 2
   -8,    0,    2,  -10,   72,    9,   73,   53,   -4,    0,
    0,    0,    0,    0,    0,    0,
d162 17
a178 18
#define YYTABLESIZE 296
const short yytable[] = {                                      27,
   15,   30,    3,    2,   17,   22,   24,   18,   26,   34,
   55,   20,   46,   47,   61,    2,   16,   24,   25,   24,
   45,   55,   48,   72,   58,   20,   20,   59,   62,   49,
   50,   51,   52,   53,    2,   60,   67,   68,   34,   34,
   19,   56,   57,   64,   54,   63,   71,   81,   24,   24,
   80,   83,   82,   57,   65,   79,   73,   74,   75,   76,
   77,   78,   66,   20,   69,   20,   19,   88,   90,   41,
   91,   41,   41,   41,   41,   84,   92,   41,   93,   94,
   41,   44,   42,   42,  101,   55,   44,   31,   96,   44,
   99,  107,   32,   44,  108,   33,   95,   98,    1,  102,
   41,   41,   44,  103,    2,    3,  104,  105,    4,    5,
  106,   31,   42,    6,    7,    1,   32,    8,    2,   33,
    9,    2,    3,   34,  110,    4,    2,   39,   53,   36,
    6,    7,   35,   37,    8,   87,   38,    9,   97,   89,
    0,   39,   40,    0,    0,   41,   42,    0,    0,    0,
   43,    0,    0,    0,    0,    0,    0,    0,    0,    0,
d190 4
a193 3
    0,   15,    0,   15,    0,    3,    2,   15,   15,    0,
    0,   15,    0,    0,    0,    0,   15,   15,    0,    0,
   15,    0,   15,   15,    3,    2,
d196 15
a210 16
    0,   12,    0,    0,  257,    4,    5,  260,    7,  261,
  259,    3,   17,   18,   25,  273,  293,  259,  293,  261,
  280,  259,  258,  261,  264,   17,   18,  293,  290,  265,
  266,  267,  268,  269,  292,  264,   35,   36,  290,  291,
  293,  290,  291,  263,  280,  292,   45,   56,  290,  291,
   55,   60,   57,  291,  264,   54,   48,   49,   50,   51,
   52,   53,  267,   55,  272,   57,  293,   66,  264,  259,
   69,  261,  262,  263,  264,  273,  290,  267,  290,  292,
  270,  262,  263,  264,   93,  259,  267,  262,  292,  270,
   89,  102,  267,  274,  103,  270,  293,  264,  271,  275,
  290,  291,  283,  263,  277,  278,  264,  294,  281,  282,
  292,  262,  293,  286,  287,  271,  267,  290,    0,  270,
  293,  277,  278,  274,  292,  281,  292,  264,  290,  292,
  286,  287,  283,  276,  290,   64,  279,  293,   86,   67,
   -1,  284,  285,   -1,   -1,  288,  289,   -1,   -1,   -1,
  293,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
d222 4
a225 3
   -1,  271,   -1,  273,   -1,  273,  273,  277,  278,   -1,
   -1,  281,   -1,   -1,   -1,   -1,  286,  287,   -1,   -1,
  290,   -1,  292,  293,  292,  292,
d251 1
a251 1
"block : rules",
a252 2
"rules : rule",
"rules : rules rule",
d473 1
a473 1
#line 111 "jamgram.y"
d477 2
a478 2
#line 113 "jamgram.y"
{ yyval.parse = yyvsp[0].parse; }
d481 1
a481 1
#line 115 "jamgram.y"
d485 1
a485 9
#line 119 "jamgram.y"
{ yyval.parse = yyvsp[0].parse; }
break;
case 6:
#line 121 "jamgram.y"
{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
break;
case 7:
#line 125 "jamgram.y"
d488 2
a489 2
case 8:
#line 127 "jamgram.y"
d492 2
a493 2
case 9:
#line 129 "jamgram.y"
d496 2
a497 2
case 10:
#line 131 "jamgram.y"
d500 2
a501 2
case 11:
#line 133 "jamgram.y"
d504 2
a505 2
case 12:
#line 135 "jamgram.y"
d508 2
a509 2
case 13:
#line 137 "jamgram.y"
d512 2
a513 2
case 14:
#line 139 "jamgram.y"
d516 2
a517 2
case 15:
#line 141 "jamgram.y"
d520 2
a521 2
case 16:
#line 143 "jamgram.y"
d524 2
a525 2
case 17:
#line 145 "jamgram.y"
d528 2
a529 2
case 18:
#line 147 "jamgram.y"
d532 2
a533 2
case 19:
#line 149 "jamgram.y"
d536 2
a537 2
case 20:
#line 151 "jamgram.y"
d540 2
a541 2
case 21:
#line 159 "jamgram.y"
d544 2
a545 2
case 22:
#line 161 "jamgram.y"
d548 2
a549 2
case 23:
#line 163 "jamgram.y"
d552 2
a553 2
case 24:
#line 171 "jamgram.y"
d556 2
a557 2
case 25:
#line 173 "jamgram.y"
d560 2
a561 2
case 26:
#line 175 "jamgram.y"
d564 2
a565 2
case 27:
#line 177 "jamgram.y"
d568 2
a569 2
case 28:
#line 179 "jamgram.y"
d572 2
a573 2
case 29:
#line 181 "jamgram.y"
d576 2
a577 2
case 30:
#line 183 "jamgram.y"
d580 2
a581 2
case 31:
#line 185 "jamgram.y"
d584 2
a585 2
case 32:
#line 187 "jamgram.y"
d588 2
a589 2
case 33:
#line 189 "jamgram.y"
d592 2
a593 2
case 34:
#line 191 "jamgram.y"
d596 2
a597 2
case 35:
#line 193 "jamgram.y"
d600 2
a601 2
case 36:
#line 204 "jamgram.y"
d604 2
a605 2
case 37:
#line 206 "jamgram.y"
d608 2
a609 2
case 38:
#line 210 "jamgram.y"
d612 2
a613 2
case 39:
#line 218 "jamgram.y"
d616 2
a617 2
case 40:
#line 220 "jamgram.y"
d620 2
a621 2
case 41:
#line 229 "jamgram.y"
d624 2
a625 2
case 42:
#line 233 "jamgram.y"
d628 2
a629 2
case 43:
#line 235 "jamgram.y"
d632 2
a633 2
case 44:
#line 239 "jamgram.y"
d636 2
a637 2
case 45:
#line 248 "jamgram.y"
d640 2
a641 2
case 46:
#line 250 "jamgram.y"
d644 2
a645 2
case 47:
#line 254 "jamgram.y"
d648 2
a649 2
case 48:
#line 256 "jamgram.y"
d652 2
a653 2
case 49:
#line 258 "jamgram.y"
d656 2
a657 2
case 50:
#line 260 "jamgram.y"
d660 2
a661 2
case 51:
#line 262 "jamgram.y"
d664 2
a665 2
case 52:
#line 264 "jamgram.y"
d668 2
a669 2
case 53:
#line 273 "jamgram.y"
d672 2
a673 2
case 54:
#line 275 "jamgram.y"
d676 1
a676 1
#line 687 "y.tab.c"
@


1.16
log
@@
text
@d2 1
a2 1
static char yysccsid[] = "@@(#)yaccpar	1.8 (Sybase) 06/01/96";
d5 22
a26 1
#line 64 "../jam/jamgram.y"
d58 2
a59 1
#line 38 "y.tab.c"
d99 3
a101 3
short yylhs[] = {                                        -1,
    0,    0,    2,    2,    3,    3,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,   12,   13,    1,
d104 1
a104 1
    4,   15,   15,    6,   10,   10,   16,   16,   16,   16,
d107 2
a108 2
short yylen[] = {                                         2,
    0,    2,    1,    4,    0,    2,    3,    3,    3,    4,
d115 12
a126 12
short yydefred[] = {                                      1,
    0,   45,    0,    0,   42,    0,   42,    0,    0,    2,
    0,    0,    0,    0,    0,   44,    0,    0,    0,    0,
    0,    0,   42,    0,    0,    0,    0,   22,   21,   23,
    0,   42,   42,   52,   49,   51,   50,   48,   47,    0,
   46,   42,   32,    0,    0,    0,    0,    0,    0,    0,
   42,    0,    0,    0,    8,   43,   17,    0,    0,    7,
    6,   42,    9,   42,    0,    0,   42,    0,    0,   35,
   26,   27,   28,   25,   29,   30,   31,   33,    0,    0,
    0,    0,    0,    5,   40,    0,   42,   10,   54,   18,
    0,    0,    0,   14,   37,    0,   12,    0,    0,    0,
    0,    0,   11,   19,   13,   16,   38,    0,   20,
d128 3
a130 3
short yydgoto[] = {                                       1,
   61,   24,   25,   26,   27,   11,   33,   82,   18,   12,
   68,   99,  108,   83,   20,   41,
d132 12
a143 12
int yysindex[] = {                                      0,
 -138,    0, -282, -248,    0, -279,    0, -267,    0,    0,
 -120, -123, -261, -248, -248,    0, -176, -257, -242, -268,
 -138, -264,    0, -249, -138, -213, -236,    0,    0,    0,
 -216,    0,    0,    0,    0,    0,    0,    0,    0, -212,
    0,    0,    0, -220, -241, -241, -241, -241, -241, -241,
    0, -248, -267, -248,    0,    0,    0, -203, -191,    0,
    0,    0,    0,    0, -235, -190,    0, -211, -210,    0,
    0,    0,    0,    0,    0,    0,    0,    0, -209, -173,
 -206, -198, -203,    0,    0, -166,    0,    0,    0,    0,
 -267, -167, -161,    0,    0, -138,    0, -154, -183, -189,
 -138, -267,    0,    0,    0,    0,    0, -180,    0,
d145 4
a148 5
int yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0, -155, -186,    0,
    0,    0,    0,    0,    0,    0, -243,    0,    0, -195,
    0,    0,    0,    0, -263, -151,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -171,
d150 3
a152 1
    0,    0, -155,    0,    0,    0,    0, -175,    0,    0,
d154 3
a156 4
    0,    0,    0,    0,    0,    0,    0,    0,    0, -253,
    0,    0, -175,    0,    0,    0,    0,    0,    0,    0,
 -155,    1,    0,    0,    0, -256,    0,    0,    0,    0,
    0, -172,    0,    0,    0,    0,    0,    0,    0,
d158 2
a159 2
int yygindex[] = {                                      0,
   -1,  -49,   40,   -2,   63,    9,   62,   45,   -8,    0,
d162 18
a179 19
#define YYTABLESIZE 294
short yytable[] = {                                      10,
   15,   52,   19,   79,   22,   43,   44,   34,   14,    3,
   13,   15,   17,   21,   23,   24,    4,   24,   42,   57,
   59,   55,   17,   17,   56,   58,   28,   63,    3,   65,
   66,   29,   53,   54,   30,    4,   34,   34,   52,   69,
   70,  100,   60,   78,   16,   80,   24,   24,   77,   62,
   64,   16,  107,   71,   72,   73,   74,   75,   76,   67,
   17,   86,   17,   41,   89,   41,   41,   41,   41,   81,
   54,   41,   84,   88,   41,   44,   42,   42,   90,   91,
   44,   45,   92,   44,   98,   52,   93,   44,   46,   47,
   48,   49,   50,   94,   41,   41,   44,   97,    5,  106,
    5,  102,  105,   51,    5,    5,   42,  101,    5,  103,
  104,  109,   39,    5,    5,    5,   36,    5,   53,    5,
    5,    5,    5,   96,   85,    5,   87,   95,    0,    0,
    5,    5,    2,    0,    5,    0,    5,    5,    3,    4,
    0,   28,    5,    0,    0,    0,   29,    6,    7,   30,
    0,    8,   34,   31,    9,   35,    0,    0,    0,    0,
   36,   37,   32,    0,   38,   39,    0,    0,    0,   40,
d190 2
a191 1
    0,   15,    0,   15,    0,    0,    0,   15,   15,    0,
d193 1
a193 1
   15,    0,   15,   15,
d195 17
a211 18
short yycheck[] = {                                       1,
    0,  259,    5,   53,    7,   14,   15,  261,  257,  273,
  293,  260,    4,  293,  282,  259,  273,  261,  280,   21,
   23,  264,   14,   15,  293,  290,  262,  264,  292,   32,
   33,  267,  290,  291,  270,  292,  290,  291,  259,   42,
  261,   91,  292,   52,  293,   54,  290,  291,   51,  263,
  267,  293,  102,   45,   46,   47,   48,   49,   50,  272,
   52,   64,   54,  259,   67,  261,  262,  263,  264,  273,
  291,  267,  264,  264,  270,  262,  263,  264,  290,  290,
  267,  258,  292,  270,   87,  259,  293,  274,  265,  266,
  267,  268,  269,  292,  290,  291,  283,  264,  271,  101,
  273,  263,  292,  280,  277,  278,  293,  275,  281,  264,
  294,  292,  264,  286,  287,  271,  292,  290,  290,  292,
  293,  277,  278,   84,   62,  281,   65,   83,   -1,   -1,
  286,  287,  271,   -1,  290,   -1,  292,  293,  277,  278,
   -1,  262,  281,   -1,   -1,   -1,  267,  286,  287,  270,
   -1,  290,  276,  274,  293,  279,   -1,   -1,   -1,   -1,
  284,  285,  283,   -1,  288,  289,   -1,   -1,   -1,  293,
d222 2
a223 1
   -1,  271,   -1,  273,   -1,   -1,   -1,  277,  278,   -1,
d225 1
a225 1
  290,   -1,  292,  293,
d227 1
a227 1
#define YYFINAL 1
d247 9
a255 9
char *yyrule[] = {
"$accept : stmts",
"stmts :",
"stmts : stmts rule",
"rules : rule0",
"rules : LOCAL args _SEMIC rule0",
"rule0 :",
"rule0 : rule0 rule",
"rule : _LBRACE rules _RBRACE",
d261 1
a261 1
"rule : FOR ARG IN args _LBRACE rules _RBRACE",
d263 2
a264 2
"rule : IF cond _LBRACE rules _RBRACE",
"rule : IF cond _LBRACE rules _RBRACE ELSE rule",
d286 1
a286 1
"case : CASE ARG _COLON rules",
a307 2
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
d309 1
a309 1
#ifndef YYMAXDEPTH
a310 1
#endif
d319 4
a322 32
#define yystacksize YYSTACKSIZE
#ifndef YYPRINTF
#define YYPRINTF printf
#endif
#ifndef YYLEXCALL
#define YYLEXCALL() yylex()
#endif
#ifndef YYTOKENERRORCALL
#define YYTOKENERRORCALL() yyerror("syntax error")
#endif
#ifndef YYSTACKERRORCALL
#define YYSTACKERRORCALL() yyerror("yacc stack overflow")
#endif
#ifndef YYINT
#define YYINT int
#endif
#ifndef YYLVAL
#define YYLVAL yylval
#endif
#ifndef YYPARSE
#define YYPARSE() yyparse()
#endif
#ifndef YYABORTCALL
#define YYABORTCALL() return (1)
#endif
#ifndef YYACCEPTCALL
#define YYACCEPTCALL() return (0)
#endif
YYINT yydebug;
YYINT yynerrs;
YYINT yyerrflag;
YYINT yychar;
d326 1
a326 1
YYSTYPE YYLVAL;
d329 1
d331 1
d334 3
a336 2
YYINT
YYPARSE()
d338 1
a338 1
    register YYINT yym, yyn, yystate;
a340 1
    extern char *getenv();
d342 1
a342 1
    if (yys = getenv("YYDEBUG"))
d359 1
a359 1
    if (yyn = yydefred[yystate]) goto yyreduce;
d362 1
a362 1
        if ((yychar = YYLEXCALL()) < 0) yychar = 0;
d369 2
a370 2
            YYPRINTF("yydebug: state %d, reading %d (%s)\n", yystate,
                    yychar, yys);
d379 2
a380 2
            YYPRINTF("yydebug: state %d, shifting to state %d\n",
                    yystate, yytable[yyn]);
d387 1
a387 1
        *++yyvsp = YYLVAL;
d399 1
a399 1
#ifdef lint
d403 2
a404 2
    YYTOKENERRORCALL();
#ifdef lint
d420 2
a421 2
                    YYPRINTF("yydebug: state %d, error recovery shifting\
 to state %d\n", *yyssp, yytable[yyn]);
d428 1
a428 1
                *++yyvsp = YYLVAL;
d435 2
a436 2
                    YYPRINTF("yydebug: error recovery discarding state %d\n",
                            *yyssp);
d453 2
a454 2
            YYPRINTF("yydebug: state %d, error recovery discards token %d (%s)\n",
                    yystate, yychar, yys);
d463 2
a464 2
        YYPRINTF("yydebug: state %d, reducing by rule %d (%s)\n",
                yystate, yyn, yyrule[yyn]);
d471 2
a472 4
#line 104 "../jam/jamgram.y"
{
			compile_builtins();
		}
d475 2
a476 10
#line 108 "../jam/jamgram.y"
{ 
			/* no target, sources in global scope */
			/* invoke statement and then free its parse */

			LOL l;
			lol_init( &l );
			(*(yyvsp[0].parse->func))( yyvsp[0].parse, &l );
			parse_free( yyvsp[0].parse );
		}
d479 1
a479 1
#line 125 "../jam/jamgram.y"
d483 1
a483 1
#line 127 "../jam/jamgram.y"
d487 2
a488 2
#line 131 "../jam/jamgram.y"
{ yyval.parse = prules( P0, P0 ); }
d491 1
a491 1
#line 133 "../jam/jamgram.y"
d495 1
a495 1
#line 137 "../jam/jamgram.y"
d499 1
a499 1
#line 139 "../jam/jamgram.y"
d503 1
a503 1
#line 141 "../jam/jamgram.y"
d507 1
a507 1
#line 143 "../jam/jamgram.y"
d511 1
a511 1
#line 145 "../jam/jamgram.y"
d515 1
a515 1
#line 147 "../jam/jamgram.y"
d519 1
a519 1
#line 149 "../jam/jamgram.y"
d523 1
a523 1
#line 151 "../jam/jamgram.y"
d527 1
a527 1
#line 153 "../jam/jamgram.y"
d531 1
a531 1
#line 155 "../jam/jamgram.y"
d535 1
a535 1
#line 157 "../jam/jamgram.y"
d539 1
a539 1
#line 159 "../jam/jamgram.y"
d543 1
a543 1
#line 161 "../jam/jamgram.y"
d547 1
a547 1
#line 163 "../jam/jamgram.y"
d551 1
a551 1
#line 171 "../jam/jamgram.y"
d555 1
a555 1
#line 173 "../jam/jamgram.y"
d559 1
a559 1
#line 175 "../jam/jamgram.y"
d563 1
a563 1
#line 183 "../jam/jamgram.y"
d567 1
a567 1
#line 185 "../jam/jamgram.y"
d571 1
a571 1
#line 187 "../jam/jamgram.y"
d575 1
a575 1
#line 189 "../jam/jamgram.y"
d579 1
a579 1
#line 191 "../jam/jamgram.y"
d583 1
a583 1
#line 193 "../jam/jamgram.y"
d587 1
a587 1
#line 195 "../jam/jamgram.y"
d591 1
a591 1
#line 197 "../jam/jamgram.y"
d595 1
a595 1
#line 199 "../jam/jamgram.y"
d599 1
a599 1
#line 201 "../jam/jamgram.y"
d603 1
a603 1
#line 203 "../jam/jamgram.y"
d607 1
a607 1
#line 205 "../jam/jamgram.y"
d611 1
a611 1
#line 216 "../jam/jamgram.y"
d615 1
a615 1
#line 218 "../jam/jamgram.y"
d619 1
a619 1
#line 222 "../jam/jamgram.y"
d623 1
a623 1
#line 230 "../jam/jamgram.y"
d627 1
a627 1
#line 232 "../jam/jamgram.y"
d631 1
a631 1
#line 241 "../jam/jamgram.y"
d635 1
a635 1
#line 245 "../jam/jamgram.y"
d639 1
a639 1
#line 247 "../jam/jamgram.y"
d643 1
a643 1
#line 251 "../jam/jamgram.y"
d647 1
a647 1
#line 260 "../jam/jamgram.y"
d651 1
a651 1
#line 262 "../jam/jamgram.y"
d655 1
a655 1
#line 266 "../jam/jamgram.y"
d659 1
a659 1
#line 268 "../jam/jamgram.y"
d663 1
a663 1
#line 270 "../jam/jamgram.y"
d667 1
a667 1
#line 272 "../jam/jamgram.y"
d671 1
a671 1
#line 274 "../jam/jamgram.y"
d675 1
a675 1
#line 276 "../jam/jamgram.y"
d679 1
a679 1
#line 285 "../jam/jamgram.y"
d683 1
a683 1
#line 287 "../jam/jamgram.y"
d686 1
a686 1
#line 704 "y.tab.c"
d696 2
a697 2
            YYPRINTF("yydebug: after reduction, shifting from state 0 to\
 state %d\n", YYFINAL);
d704 1
a704 1
            if ((yychar = YYLEXCALL()) < 0) yychar = 0;
d711 2
a712 2
                YYPRINTF("yydebug: state %d, reading %d (%s)\n",
                        YYFINAL, yychar, yys);
d726 2
a727 2
        YYPRINTF("yydebug: after reduction, shifting from state %d \
to state %d\n", *yyssp, yystate);
d737 1
a737 1
    YYSTACKERRORCALL();
d739 1
a739 1
    YYABORTCALL();
d741 1
a741 1
    YYACCEPTCALL();
@


1.15
log
@@
text
@d5 1
a5 1
#line 64 "jamgram.y"
d478 1
a478 1
#line 104 "jamgram.y"
d484 1
a484 1
#line 108 "jamgram.y"
d496 1
a496 1
#line 125 "jamgram.y"
d500 1
a500 1
#line 127 "jamgram.y"
d504 1
a504 1
#line 131 "jamgram.y"
d508 1
a508 1
#line 133 "jamgram.y"
d512 1
a512 1
#line 137 "jamgram.y"
d516 1
a516 1
#line 139 "jamgram.y"
d520 1
a520 1
#line 141 "jamgram.y"
d524 1
a524 1
#line 143 "jamgram.y"
d528 1
a528 1
#line 145 "jamgram.y"
d532 1
a532 1
#line 147 "jamgram.y"
d536 1
a536 1
#line 149 "jamgram.y"
d540 1
a540 1
#line 151 "jamgram.y"
d544 1
a544 1
#line 153 "jamgram.y"
d548 1
a548 1
#line 155 "jamgram.y"
d552 1
a552 1
#line 157 "jamgram.y"
d556 1
a556 1
#line 159 "jamgram.y"
d560 1
a560 1
#line 161 "jamgram.y"
d564 1
a564 1
#line 163 "jamgram.y"
d568 1
a568 1
#line 171 "jamgram.y"
d572 1
a572 1
#line 173 "jamgram.y"
d576 1
a576 1
#line 175 "jamgram.y"
d580 1
a580 1
#line 183 "jamgram.y"
d584 1
a584 1
#line 185 "jamgram.y"
d588 1
a588 1
#line 187 "jamgram.y"
d592 1
a592 1
#line 189 "jamgram.y"
d596 1
a596 1
#line 191 "jamgram.y"
d600 1
a600 1
#line 193 "jamgram.y"
d604 1
a604 1
#line 195 "jamgram.y"
d608 1
a608 1
#line 197 "jamgram.y"
d612 1
a612 1
#line 199 "jamgram.y"
d616 1
a616 1
#line 201 "jamgram.y"
d620 1
a620 1
#line 203 "jamgram.y"
d624 1
a624 1
#line 205 "jamgram.y"
d628 1
a628 1
#line 216 "jamgram.y"
d632 1
a632 1
#line 218 "jamgram.y"
d636 1
a636 1
#line 222 "jamgram.y"
d640 1
a640 1
#line 230 "jamgram.y"
d644 1
a644 1
#line 232 "jamgram.y"
d648 1
a648 1
#line 241 "jamgram.y"
d652 1
a652 1
#line 245 "jamgram.y"
d656 1
a656 1
#line 247 "jamgram.y"
d660 1
a660 1
#line 251 "jamgram.y"
d664 1
a664 1
#line 260 "jamgram.y"
d668 1
a668 1
#line 262 "jamgram.y"
d672 1
a672 1
#line 266 "jamgram.y"
d676 1
a676 1
#line 268 "jamgram.y"
d680 1
a680 1
#line 270 "jamgram.y"
d684 1
a684 1
#line 272 "jamgram.y"
d688 1
a688 1
#line 274 "jamgram.y"
d692 1
a692 1
#line 276 "jamgram.y"
d696 1
a696 1
#line 285 "jamgram.y"
d700 1
a700 1
#line 287 "jamgram.y"
@


1.14
log
@@
text
@d110 1
a110 1
short yysindex[] = {                                      0,
d123 1
a123 1
short yyrindex[] = {                                      0,
d136 1
a136 1
short yygindex[] = {                                      0,
d316 12
d335 1
a335 1
YYSTYPE yylval;
d342 1
a342 1
yyparse()
d394 1
a394 1
        *++yyvsp = yylval;
d435 1
a435 1
                *++yyvsp = yylval;
d703 1
a703 1
#line 692 "y.tab.c"
d756 1
a756 1
    return (1);
d758 1
a758 1
    return (0);
@


1.13
log
@@
text
@d2 1
a2 1
static char yysccsid[] = "@@(#)yaccpar	1.9 (Berkeley) 02/21/93";
a4 6
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
d37 1
a37 1
#line 44 "y.tab.c"
d99 1
a99 1
    0,    0,    0,    0,    8,   43,   17,    0,    0,    7,
d111 11
a121 11
 -150,    0, -282, -250,    0, -281,    0, -268,    0,    0,
 -112, -115, -265, -250, -250,    0, -120, -246, -245, -264,
 -150, -254,    0, -267, -150, -221, -209,    0,    0,    0,
 -208,    0,    0,    0,    0,    0,    0,    0,    0, -212,
    0,    0,    0, -233, -229, -229, -229, -229, -229, -229,
 -229, -250, -268, -250,    0,    0,    0, -204, -194,    0,
    0,    0,    0,    0, -235, -192,    0, -217, -211,    0,
    0,    0,    0,    0,    0,    0,    0,    0, -210, -178,
 -203, -201, -204,    0,    0, -180,    0,    0,    0,    0,
 -268, -186, -169,    0,    0, -150,    0, -166, -199, -193,
 -150, -268,    0,    0,    0,    0,    0, -183,    0,
d124 4
a127 4
    0,    0,    0,    0,    0,    0,    0, -167, -196,    0,
    0,    0,    0,    0,    0,    0, -257,    0,    0, -187,
    0,    0,    0,    0, -255, -158,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -177,
d129 1
a129 1
    0,    0, -167,    0,    0,    0,    0, -176,    0,    0,
d131 4
a134 4
    0,    0,    0,    0,    0,    0,    0,    0,    0, -252,
    0,    0, -176,    0,    0,    0,    0,    0,    0,    0,
 -167,    1,    0,    0,    0, -251,    0,    0,    0,    0,
    0, -185,    0,    0,    0,    0,    0,    0,    0,
d137 1
a137 1
   -1,  -45,   28,   -2,   53,    2,   52,   35,    9,    0,
d142 17
a158 18
   15,   24,   19,   24,   22,   17,   14,   79,   34,   15,
   13,   21,   52,   23,   42,   17,   17,    3,   55,   57,
   59,    4,   43,   44,   60,   52,   28,   70,   56,   65,
   66,   29,   24,   24,   30,   58,    3,   34,   34,   69,
    4,   62,   16,   53,   54,  100,   71,   72,   73,   74,
   75,   76,   77,   17,   63,   17,  107,   54,   64,   67,
   78,   86,   80,   16,   89,   44,   42,   42,   81,   84,
   44,   88,   90,   44,   41,   41,   41,   44,   91,   41,
   52,   92,   41,   97,   98,    5,   44,    5,  101,   93,
   94,    5,    5,  102,  104,    5,   42,  103,  105,  106,
    5,    5,   41,    5,    5,   39,    5,    5,  109,    5,
    5,   96,   53,    5,   85,   36,   87,   95,    5,    5,
    2,    0,    5,    0,    5,    5,    3,    4,    0,    0,
    5,    0,    0,    0,    0,    6,    7,   45,    0,    8,
    0,    0,    9,    0,   46,   47,   48,   49,   50,   28,
    0,    0,    0,    0,   29,    0,    0,   30,    0,   51,
   34,   31,    0,   35,    0,    0,    0,    0,   36,   37,
   32,    0,   38,   39,    0,    0,    0,   40,    0,    0,
d168 1
d174 17
a190 18
    0,  259,    5,  261,    7,    4,  257,   53,  261,  260,
  293,  293,  259,  282,  280,   14,   15,  273,  264,   21,
   23,  273,   14,   15,  292,  259,  262,  261,  293,   32,
   33,  267,  290,  291,  270,  290,  292,  290,  291,   42,
  292,  263,  293,  290,  291,   91,   45,   46,   47,   48,
   49,   50,   51,   52,  264,   54,  102,  291,  267,  272,
   52,   64,   54,  293,   67,  262,  263,  264,  273,  264,
  267,  264,  290,  270,  262,  263,  264,  274,  290,  267,
  259,  292,  270,  264,   87,  271,  283,  273,  275,  293,
  292,  277,  278,  263,  294,  281,  293,  264,  292,  101,
  286,  287,  290,  271,  290,  264,  292,  293,  292,  277,
  278,   84,  290,  281,   62,  292,   65,   83,  286,  287,
  271,   -1,  290,   -1,  292,  293,  277,  278,   -1,   -1,
  281,   -1,   -1,   -1,   -1,  286,  287,  258,   -1,  290,
   -1,   -1,  293,   -1,  265,  266,  267,  268,  269,  262,
   -1,   -1,   -1,   -1,  267,   -1,   -1,  270,   -1,  280,
  276,  274,   -1,  279,   -1,   -1,   -1,   -1,  284,  285,
  283,   -1,  288,  289,   -1,   -1,   -1,  293,   -1,   -1,
d200 1
d257 1
a257 1
"cond : arg1 IN arg1",
d286 2
d289 1
a289 1
#undef YYMAXDEPTH
d291 1
d300 20
a319 4
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
a325 1
#define yystacksize YYSTACKSIZE
a326 1
#define YYREJECT goto yyabort
d329 1
a329 1
int
d332 1
a332 1
    register int yym, yyn, yystate;
d357 1
a357 1
        if ((yychar = yylex()) < 0) yychar = 0;
d364 2
a365 2
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
d374 2
a375 2
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
d398 1
a398 1
    yyerror("syntax error");
d415 2
a416 2
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
d430 2
a431 2
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
d448 2
a449 2
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
d458 2
a459 2
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
d691 1
a691 1
#line 681 "y.tab.c"
d701 2
a702 2
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
d709 1
a709 1
            if ((yychar = yylex()) < 0) yychar = 0;
d716 2
a717 2
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
d731 2
a732 2
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
d742 1
a742 1
    yyerror("yacc stack overflow");
@


1.12
log
@@
text
@d11 1
a11 1
#line 63 "jamgram.y"
d31 1
a31 1
# define psete( s,s1,f )  parse_make( compile_setexec,P0,P0,s,s1,L0,L0,f )
d59 23
a81 22
#define CASE 272
#define DEFAULT 273
#define ELSE 274
#define EXISTING 275
#define FOR 276
#define IF 277
#define IGNORE 278
#define IN 279
#define INCLUDE 280
#define LOCAL 281
#define ON 282
#define PIECEMEAL 283
#define QUIETLY 284
#define RULE 285
#define SWITCH 286
#define TOGETHER 287
#define UPDATED 288
#define _LBRACE 289
#define _BARBAR 290
#define _RBRACE 291
#define ARG 292
#define STRING 293
d85 5
a89 5
    1,    1,    1,    1,    1,    1,   11,    1,    1,    7,
    7,    7,    9,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    8,    8,   12,    5,    5,    4,
   13,   13,    6,   10,   10,   14,   14,   14,   14,   14,
   14,
d92 6
a97 6
    0,    2,    1,    4,    0,    2,    3,    3,    4,    6,
    5,    7,    5,    5,    7,    3,    0,    5,    3,    1,
    1,    1,    1,    3,    3,    3,    3,    3,    3,    3,
    2,    3,    3,    3,    0,    2,    4,    1,    3,    1,
    0,    2,    1,    0,    2,    1,    1,    1,    1,    1,
    1,
d100 11
a110 11
    0,   44,    0,    0,   41,    0,   41,    0,    0,    2,
    0,    0,    0,    0,    0,   43,    0,    0,    0,    0,
    0,    0,   41,    0,    0,    0,    0,   21,   20,   22,
    0,   41,   41,   51,   48,   50,   49,   47,   46,   17,
   45,   41,   31,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    7,   42,   16,    0,    0,   19,
    6,   41,    8,   41,    0,    0,    0,    0,   34,   25,
   26,   27,   24,   28,   29,   30,   32,    0,    0,    0,
    0,    0,    5,   39,    0,   41,    9,   18,    0,    0,
    0,   13,   36,    0,   11,    0,    0,    0,    0,   10,
   12,   15,   37,
d113 2
a114 2
   61,   24,   25,   26,   27,   11,   33,   81,   18,   12,
   67,   82,   20,   41,
d117 11
a127 11
 -144,    0, -282, -253,    0, -277,    0, -262,    0,    0,
 -133, -166, -251, -253, -253,    0, -115, -257, -242, -267,
 -144, -263,    0, -256, -144, -229, -228,    0,    0,    0,
 -223,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -247, -246, -246, -246, -246, -246, -246,
 -246, -253, -262, -253,    0,    0,    0, -234, -205,    0,
    0,    0,    0,    0, -198, -204, -225, -218,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -217, -182, -211,
 -216, -234,    0,    0, -177,    0,    0,    0, -262, -192,
 -175,    0,    0, -144,    0, -174, -202, -144, -262,    0,
    0,    0,    0,
d130 4
a133 4
    0,    0,    0,    0,    0,    0,    0, -161, -197,    0,
    0,    0,    0,    0,    0,    0, -248,    0,    0, -184,
    0,    0,    0,    0, -264, -173,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
d135 1
a135 1
    0,    0, -161,    0,    0,    0,    0, -199,    0,    0,
d137 4
a140 4
    0,    0,    0,    0,    0,    0,    0,    0, -232,    0,
    0, -199,    0,    0,    0,    0,    0,    0, -161,    1,
    0,    0,    0, -254,    0,    0,    0,    0, -178,    0,
    0,    0,    0,
d143 2
a144 2
   -1,  -44,   13,   -2,   38,    2,   36,   21,    9,    0,
    0,    0,    0,    0,
d146 1
a146 1
#define YYTABLESIZE 293
d148 18
a165 18
   14,   52,   19,   14,   22,   17,   15,    3,   78,   13,
   23,   52,   23,   69,   21,   17,   17,    4,   23,   57,
   59,   55,   43,   44,   56,   58,    3,   42,   33,   65,
   66,   53,   54,   62,   60,   63,    4,   80,   16,   68,
   23,   23,   54,   64,   97,   16,   70,   71,   72,   73,
   74,   75,   76,   17,  103,   17,   33,   33,   83,   87,
   77,   85,   79,   28,   43,   41,   41,   88,   29,   43,
   89,   30,   43,   90,   92,   43,   52,   40,   40,   40,
   91,   98,   40,   96,   43,   40,   95,   99,  101,  100,
   38,   35,    5,    5,   41,   94,  102,    5,    5,   84,
   86,    5,   93,    0,   40,    0,    5,    5,   34,    5,
    5,   35,    5,    5,    5,    5,   36,   37,    5,    0,
   38,   39,    0,    5,    5,   40,    2,    5,   28,    5,
    5,    3,    4,   29,    0,    5,   30,    0,    0,   31,
    6,    7,   45,    0,    8,    0,    0,    9,   32,   46,
   47,   48,   49,   50,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   51,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
d175 3
a177 3
    0,   14,   14,    0,    0,    0,   14,   14,    0,    0,
   14,    0,    0,    0,    0,   14,   14,    0,    0,   14,
    0,   14,   14,
d180 18
a197 18
    0,  259,    5,  257,    7,    4,  260,  272,   53,  292,
  259,  259,  261,  261,  292,   14,   15,  272,  281,   21,
   23,  264,   14,   15,  292,  289,  291,  279,  261,   32,
   33,  289,  290,  263,  291,  264,  291,  272,  292,   42,
  289,  290,  290,  267,   89,  292,   45,   46,   47,   48,
   49,   50,   51,   52,   99,   54,  289,  290,  264,  264,
   52,   64,   54,  262,  262,  263,  264,  293,  267,  267,
  289,  270,  270,  291,  291,  273,  259,  262,  263,  264,
  292,  274,  267,   86,  282,  270,  264,  263,  291,  264,
  264,  291,  271,  272,  292,   83,   98,  276,  277,   62,
   65,  280,   82,   -1,  289,   -1,  285,  286,  275,  271,
  289,  278,  291,  292,  276,  277,  283,  284,  280,   -1,
  287,  288,   -1,  285,  286,  292,  271,  289,  262,  291,
  292,  276,  277,  267,   -1,  280,  270,   -1,   -1,  273,
  285,  286,  258,   -1,  289,   -1,   -1,  292,  282,  265,
  266,  267,  268,  269,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  279,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
d207 3
a209 3
   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,   -1,
  280,   -1,   -1,   -1,   -1,  285,  286,   -1,   -1,  289,
   -1,  291,  292,
d215 1
a215 1
#define YYMAXTOKEN 293
d227 3
a229 3
"ACTIONS","CASE","DEFAULT","ELSE","EXISTING","FOR","IF","IGNORE","IN","INCLUDE",
"LOCAL","ON","PIECEMEAL","QUIETLY","RULE","SWITCH","TOGETHER","UPDATED",
"_LBRACE","_BARBAR","_RBRACE","ARG","STRING",
d239 1
d251 2
a252 2
"rule : ACTIONS eflags ARG $$1 STRING",
"rule : _LBRACE rules _RBRACE",
d285 2
d455 1
a455 1
#line 103 "jamgram.y"
d461 1
a461 1
#line 107 "jamgram.y"
d473 1
a473 1
#line 124 "jamgram.y"
d477 1
a477 1
#line 126 "jamgram.y"
d481 1
a481 1
#line 130 "jamgram.y"
d485 1
a485 1
#line 132 "jamgram.y"
d489 2
a490 2
#line 136 "jamgram.y"
{ yyval.parse = pincl( yyvsp[-1].list ); }
d493 2
a494 2
#line 138 "jamgram.y"
{ yyval.parse = prule( yyvsp[-2].string, yyvsp[-1].parse ); }
d497 2
a498 2
#line 140 "jamgram.y"
{ yyval.parse = pset( yyvsp[-3].list, yyvsp[-1].list, yyvsp[-2].number ); }
d501 2
a502 2
#line 142 "jamgram.y"
{ yyval.parse = pstng( yyvsp[-3].list, yyvsp[-5].list, yyvsp[-1].list, yyvsp[-2].number ); }
d505 2
a506 2
#line 144 "jamgram.y"
{ yyval.parse = pset( yyvsp[-4].list, yyvsp[-1].list, ASSIGN_DEFAULT ); }
d509 2
a510 2
#line 146 "jamgram.y"
{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-1].parse, yyvsp[-3].list ); }
d513 2
a514 2
#line 148 "jamgram.y"
{ yyval.parse = pswitch( yyvsp[-3].list, yyvsp[-1].parse ); }
d517 2
a518 2
#line 150 "jamgram.y"
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, P0 ) ); }
d521 2
a522 2
#line 152 "jamgram.y"
{ yyval.parse = pif( yyvsp[-5].parse, pthen( yyvsp[-3].parse, yyvsp[0].parse ) ); }
d525 2
a526 2
#line 154 "jamgram.y"
{ yyval.parse = psetc( yyvsp[-1].string, yyvsp[0].parse ); }
d529 2
a530 2
#line 156 "jamgram.y"
{ yymode( SCAN_STRING ); }
d533 2
a534 3
#line 158 "jamgram.y"
{ yyval.parse = psete( yyvsp[-2].string, yyvsp[0].string, yyvsp[-3].number );
		  yymode( SCAN_NORMAL ); }
d538 1
a538 1
{ yyval.parse = yyvsp[-1].parse; }
d541 2
a542 2
#line 169 "jamgram.y"
{ yyval.number = ASSIGN_SET; }
d546 1
a546 1
{ yyval.number = ASSIGN_APPEND; }
d550 1
a550 1
{ yyval.number = ASSIGN_DEFAULT; }
d553 2
a554 2
#line 181 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yyvsp[0].list, L0 ); }
d558 1
a558 1
{ yyval.parse = pcomp( COND_EQUALS, yyvsp[-2].list, yyvsp[0].list ); }
d562 1
a562 1
{ yyval.parse = pcomp( COND_NOTEQ, yyvsp[-2].list, yyvsp[0].list ); }
d566 1
a566 1
{ yyval.parse = pcomp( COND_LESS, yyvsp[-2].list, yyvsp[0].list ); }
d570 1
a570 1
{ yyval.parse = pcomp( COND_LESSEQ, yyvsp[-2].list, yyvsp[0].list ); }
d574 1
a574 1
{ yyval.parse = pcomp( COND_MORE, yyvsp[-2].list, yyvsp[0].list ); }
d578 1
a578 1
{ yyval.parse = pcomp( COND_MOREEQ, yyvsp[-2].list, yyvsp[0].list ); }
d582 1
a582 1
{ yyval.parse = pcomp( COND_IN, yyvsp[-2].list, yyvsp[0].list ); }
d586 1
a586 1
{ yyval.parse = pcond( COND_NOT, yyvsp[0].parse, P0 ); }
d590 1
a590 1
{ yyval.parse = pcond( COND_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
d594 1
a594 1
{ yyval.parse = pcond( COND_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
d598 1
a598 1
{ yyval.parse = yyvsp[-1].parse; }
d601 2
a602 2
#line 214 "jamgram.y"
{ yyval.parse = P0; }
d606 1
a606 1
{ yyval.parse = pcases( yyvsp[-1].parse, yyvsp[0].parse ); }
d609 2
a610 2
#line 220 "jamgram.y"
{ yyval.parse = pcase( yyvsp[-2].string, yyvsp[0].parse ); }
d613 2
a614 2
#line 228 "jamgram.y"
{ yyval.parse = plol( P0, yyvsp[0].list ); }
d618 1
a618 1
{ yyval.parse = plol( yyvsp[0].parse, yyvsp[-2].list ); }
d621 2
a622 2
#line 239 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
d625 2
a626 2
#line 243 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); }
d630 1
a630 1
{ yyval.list = list_new( yyvsp[-1].list, copystr( yyvsp[0].string ) ); }
d633 2
a634 2
#line 249 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yyvsp[0].string ) ); }
d637 2
a638 2
#line 258 "jamgram.y"
{ yyval.number = 0; }
d642 1
a642 1
{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
d645 2
a646 2
#line 264 "jamgram.y"
{ yyval.number = EXEC_UPDATED; }
d650 1
a650 1
{ yyval.number = EXEC_TOGETHER; }
d654 1
a654 1
{ yyval.number = EXEC_IGNORE; }
d658 1
a658 1
{ yyval.number = EXEC_QUIETLY; }
d662 1
a662 1
{ yyval.number = EXEC_PIECEMEAL; }
d666 4
d672 9
a680 1
#line 666 "y.tab.c"
@


1.11
log
@@
text
@d1 11
a11 39
# define _BANG 257
# define _BANG_EQUALS 258
# define _AMPERAMPER 259
# define _LPAREN 260
# define _RPAREN 261
# define _PLUS_EQUALS 262
# define _COLON 263
# define _SEMIC 264
# define _LANGLE 265
# define _LANGLE_EQUALS 266
# define _EQUALS 267
# define _RANGLE 268
# define _RANGLE_EQUALS 269
# define _QUESTION_EQUALS 270
# define ACTIONS 271
# define CASE 272
# define DEFAULT 273
# define ELSE 274
# define EXISTING 275
# define FOR 276
# define IF 277
# define IGNORE 278
# define IN 279
# define INCLUDE 280
# define LOCAL 281
# define ON 282
# define PIECEMEAL 283
# define QUIETLY 284
# define RULE 285
# define SWITCH 286
# define TOGETHER 287
# define UPDATED 288
# define _LBRACE 289
# define _BARBAR 290
# define _RBRACE 291
# define ARG 292
# define STRING 293

# line 63 "jamgram.y"
d43 168
a210 142

#ifdef __STDC__
#include <stdlib.h>
#include <string.h>
#else
#include <malloc.h>
#include <memory.h>
#endif

#ifdef __cplusplus

#ifndef yyerror
	void yyerror(const char *);
#endif

#ifndef yylex
#ifdef __EXTERN_C__
	extern "C" { int yylex(void); }
#else
	int yylex(void);
#endif
#endif
	int yyparse(void);

#endif
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
#ifndef YYSTYPE
#define YYSTYPE int
#endif
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256
yytabelem yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 4,
	263, 41,
	264, 41,
	292, 41,
	-2, 43,
	};
# define YYNPROD 52
# define YYLAST 167
yytabelem yyact[]={

    10,    26,    95,    93,    27,     6,     8,    28,    44,     3,
    85,    44,    35,    29,     9,     7,    63,    22,    11,    60,
    33,     4,   101,    94,    62,    61,    91,    64,    59,    58,
    41,    90,    42,    56,   100,    20,    28,    74,    40,    45,
    19,    43,    45,    21,    97,    20,    18,    31,    89,    47,
    19,    87,    68,    21,    36,    17,    48,    49,    46,    50,
    51,    34,    99,    37,    44,    65,    32,     2,    72,    15,
    52,     5,    16,    12,    57,    14,    13,    23,    73,    86,
    25,    24,    30,     1,     0,     0,    38,    39,     0,     0,
     0,    75,     0,     0,     0,    55,     0,     0,    25,    25,
     0,     0,     0,    66,     0,     0,     0,     0,    53,    54,
    70,    71,    69,    67,     0,     0,    25,    25,    78,    79,
    80,    81,    82,    83,    84,     0,    76,    77,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,    98,    88,
     0,     0,    92,     0,     0,     0,     0,   102,     0,     0,
     0,     0,     0,     0,    96,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   103 };
yytabelem yypact[]={

-10000000,  -271,-10000000,-10000000,-10000000,  -227,  -275,-10000000,  -256,  -279,
-10000000,  -261,  -203,  -280,  -210,  -200,-10000000,-10000000,  -229,-10000000,
-10000000,-10000000,  -249,  -257,  -248,  -209,  -256,  -256,-10000000,  -271,
  -259,  -264,  -271,-10000000,-10000000,-10000000,-10000000,-10000000,  -212,  -217,
-10000000,-10000000,  -235,  -261,  -256,  -256,  -285,  -285,  -285,  -285,
  -285,  -285,  -285,-10000000,  -251,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -213,-10000000,-10000000,-10000000,
  -216,  -258,  -265,  -235,  -289,  -268,-10000000,  -195,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -291,-10000000,  -220,-10000000,
  -261,-10000000,-10000000,  -201,  -240,-10000000,  -271,-10000000,  -269,  -261,
  -271,-10000000,-10000000,-10000000 };
yytabelem yypgo[]={

     0,    83,    65,    47,    66,    69,    75,    71,    72,    68,
    81,    82,    79,    78,    76,    74 };
yytabelem yyr1[]={

     0,     1,     1,     3,     3,     4,     4,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    12,     2,     2,
     8,     8,     8,    10,    10,    10,    10,    10,    10,    10,
    10,    10,    10,    10,    10,     9,     9,    13,     6,     6,
     5,    14,    14,     7,    11,    11,    15,    15,    15,    15,
    15,    15 };
yytabelem yyr2[]={

     0,     1,     5,     3,     9,     1,     5,     7,     7,     9,
    13,    11,    15,    11,    11,    15,     7,     1,    11,     7,
     3,     3,     3,     3,     7,     7,     7,     7,     7,     7,
     7,     5,     7,     7,     7,     1,     5,     9,     3,     7,
     3,     1,     5,     3,     1,     5,     3,     3,     3,     3,
     3,     3 };
yytabelem yychk[]={

-10000000,    -1,    -2,   280,   292,    -7,   276,   286,   277,   285,
   271,   289,    -5,   -14,    -6,    -5,    -8,   282,   273,   267,
   262,   270,   292,    -5,   -10,    -7,   257,   260,   292,   292,
   -11,    -3,    -4,   281,   264,   292,   264,   263,    -5,    -5,
   267,   279,   289,   289,   259,   290,   267,   258,   265,   266,
   268,   269,   279,   -10,   -10,    -2,   292,   -15,   288,   287,
   278,   284,   283,   275,   291,    -2,    -5,    -6,   264,    -8,
    -5,    -5,    -9,   -13,   272,    -3,   -10,   -10,    -7,    -7,
    -7,    -7,    -7,    -7,    -7,   261,   -12,   264,    -5,   264,
   289,   291,    -9,   292,   291,   293,    -4,   264,    -3,   263,
   274,   291,    -3,    -2 };
yytabelem yydef[]={

     1,    -2,     2,    41,    -2,     0,     0,    41,     0,     0,
    44,     5,     0,    40,     0,    38,    41,    41,     0,    20,
    21,    22,     0,     0,     0,    23,     0,     0,    43,     0,
     0,     0,     3,    41,     7,    42,     8,    41,     0,     0,
    41,    41,    35,     5,     0,     0,     0,     0,     0,     0,
     0,     0,     0,    31,     0,    16,    17,    45,    46,    47,
    48,    49,    50,    51,    19,     6,     0,    39,     9,    41,
     0,     0,     0,    35,     0,     0,    32,    33,    24,    25,
    26,    27,    28,    29,    30,    34,     0,     5,     0,    11,
     5,    13,    36,     0,    14,    18,     4,    10,     0,     5,
     0,    12,    37,    15 };
typedef struct
#ifdef __cplusplus
	yytoktype
#endif
{ char *t_name; int t_val; } yytoktype;
d212 1
a212 1
#	define YYDEBUG	0	/* don't allow debugging */
d214 1
a214 1

d216 13
a228 41

yytoktype yytoks[] =
{
	"_BANG",	257,
	"_BANG_EQUALS",	258,
	"_AMPERAMPER",	259,
	"_LPAREN",	260,
	"_RPAREN",	261,
	"_PLUS_EQUALS",	262,
	"_COLON",	263,
	"_SEMIC",	264,
	"_LANGLE",	265,
	"_LANGLE_EQUALS",	266,
	"_EQUALS",	267,
	"_RANGLE",	268,
	"_RANGLE_EQUALS",	269,
	"_QUESTION_EQUALS",	270,
	"ACTIONS",	271,
	"CASE",	272,
	"DEFAULT",	273,
	"ELSE",	274,
	"EXISTING",	275,
	"FOR",	276,
	"IF",	277,
	"IGNORE",	278,
	"IN",	279,
	"INCLUDE",	280,
	"LOCAL",	281,
	"ON",	282,
	"PIECEMEAL",	283,
	"QUIETLY",	284,
	"RULE",	285,
	"SWITCH",	286,
	"TOGETHER",	287,
	"UPDATED",	288,
	"_LBRACE",	289,
	"_BARBAR",	290,
	"_RBRACE",	291,
	"ARG",	292,
	"STRING",	293,
	"-unknown-",	-1	/* ends search */
d230 53
a282 55

char * yyreds[] =
{
	"-no such reduction-",
	"stmts : /* empty */",
	"stmts : stmts rule",
	"rules : rule0",
	"rules : LOCAL args _SEMIC rule0",
	"rule0 : /* empty */",
	"rule0 : rule0 rule",
	"rule : INCLUDE args _SEMIC",
	"rule : ARG lol _SEMIC",
	"rule : arg1 assign args _SEMIC",
	"rule : arg1 ON args assign args _SEMIC",
	"rule : arg1 DEFAULT _EQUALS args _SEMIC",
	"rule : FOR ARG IN args _LBRACE rules _RBRACE",
	"rule : SWITCH args _LBRACE cases _RBRACE",
	"rule : IF cond _LBRACE rules _RBRACE",
	"rule : IF cond _LBRACE rules _RBRACE ELSE rule",
	"rule : RULE ARG rule",
	"rule : ACTIONS eflags ARG",
	"rule : ACTIONS eflags ARG STRING",
	"rule : _LBRACE rules _RBRACE",
	"assign : _EQUALS",
	"assign : _PLUS_EQUALS",
	"assign : _QUESTION_EQUALS",
	"cond : arg1",
	"cond : arg1 _EQUALS arg1",
	"cond : arg1 _BANG_EQUALS arg1",
	"cond : arg1 _LANGLE arg1",
	"cond : arg1 _LANGLE_EQUALS arg1",
	"cond : arg1 _RANGLE arg1",
	"cond : arg1 _RANGLE_EQUALS arg1",
	"cond : arg1 IN arg1",
	"cond : _BANG cond",
	"cond : cond _AMPERAMPER cond",
	"cond : cond _BARBAR cond",
	"cond : _LPAREN cond _RPAREN",
	"cases : /* empty */",
	"cases : case cases",
	"case : CASE ARG _COLON rules",
	"lol : args",
	"lol : args _COLON lol",
	"args : argsany",
	"argsany : /* empty */",
	"argsany : argsany ARG",
	"arg1 : ARG",
	"eflags : /* empty */",
	"eflags : eflags eflag",
	"eflag : UPDATED",
	"eflag : TOGETHER",
	"eflag : IGNORE",
	"eflag : QUIETLY",
	"eflag : PIECEMEAL",
	"eflag : EXISTING",
a283 37
#endif /* YYDEBUG */
/*
 * Copyright (c) 1993 by Sun Microsystems, Inc.
 */

#pragma ident	"@@(#)yaccpar	6.12	93/06/07 SMI"

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( "syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
d285 2
a286 37

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */

int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */



#ifdef YYNMBCHARS
#define YYLEX()		yycvtok(yylex())
/*
** yycvtok - return a token if i is a wchar_t value that exceeds 255.
**	If i<255, i itself is the token.  If i>255 but the neither 
**	of the 30th or 31st bit is on, i is already a token.
*/
#if defined(__STDC__) || defined(__cplusplus)
int yycvtok(int i)
#else
int yycvtok(i) int i;
d288 3
a290 36
{
	int first = 0;
	int last = YYNMBCHARS - 1;
	int mid;
	wchar_t j;

	if(i&0x60000000){/*Must convert to a token. */
		if( yymbchars[last].character < i ){
			return i;/*Giving up*/
		}
		while ((last>=first)&&(first>=0)) {/*Binary search loop*/
			mid = (first+last)/2;
			j = yymbchars[mid].character;
			if( j==i ){/*Found*/ 
				return yymbchars[mid].tvalue;
			}else if( j<i ){
				first = mid + 1;
			}else{
				last = mid -1;
			}
		}
		/*No entry in the table.*/
		return i;/* Giving up.*/
	}else{/* i is already a token. */
		return i;
	}
}
#else/*!YYNMBCHARS*/
#define YYLEX()		yylex()
#endif/*!YYNMBCHARS*/

/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
d292 5
a296 1
int yyparse()
a297 15
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */

#if defined(__cplusplus) || defined(lint)
/*
	hacks to please C++ and lint - goto's inside switch should never be
	executed; yypvt is set to 0 to avoid "used before set" warning.
*/
	static int __yaccpar_lint_hack__ = 0;
	switch (__yaccpar_lint_hack__)
	{
		case 1: goto yyerrlab;
		case 2: goto yynewstate;
	}
	yypvt = 0;
d299 22
a320 11

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;
d322 6
a327 9
#if YYMAXDEPTH <= 0
	if (yymaxdepth <= 0)
	{
		if ((yymaxdepth = YYEXPAND(0)) <= 0)
		{
			yyerror("yacc initialization error");
			YYABORT;
		}
	}
d330 3
a332 16
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */
	goto yystack;	/* moved from 6 lines above to here to please C++ */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;
d334 3
a336 8
		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
d338 5
a342 7
		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
d344 8
a351 60
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			int yyps_index = (yy_ps - yys);
			int yypv_index = (yy_pv - yyv);
			int yypvt_index = (yypvt - yyv);
			int yynewmax;
#ifdef YYEXPAND
			yynewmax = YYEXPAND(yymaxdepth);
#else
			yynewmax = 2 * yymaxdepth;	/* double table size */
			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				char *newyys = (char *)YYNEW(int);
				char *newyyv = (char *)YYNEW(YYSTYPE);
				if (newyys != 0 && newyyv != 0)
				{
					yys = YYCOPY(newyys, yys, int);
					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
				}
				else
					yynewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				yys = YYENLARGE(yys, int);
				yyv = YYENLARGE(yyv, YYSTYPE);
				if (yys == 0 || yyv == 0)
					yynewmax = 0;	/* failed */
			}
d353 4
a356 20
			if (yynewmax <= yymaxdepth)	/* tables not expanded */
			{
				yyerror( "yacc stack overflow" );
				YYABORT;
			}
			yymaxdepth = yynewmax;

			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
d358 3
a360 4
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
d362 19
a380 41
		if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			printf( "Received token " );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
d382 16
a397 2
			if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
				yychar = 0;		/* reached EOF */
d399 14
a412 89
			if ( yydebug && yytmp )
			{
				register int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror( "syntax error" );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
			skip_init:
				yynerrs++;
				/* FALLTHRU */
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
d414 3
a416 5
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
d418 9
a426 9
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
d428 13
a440 43
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					printf( "Error recovery discards " );
					if ( yychar == 0 )
						printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
d442 3
a444 8
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
d446 4
a449 53
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
d451 1
a451 1
# line 103 "jamgram.y"
d454 2
a455 1
		} break;
d457 1
a457 1
# line 107 "jamgram.y"
d464 4
a467 3
			(*(yypvt[-0].parse->func))( yypvt[-0].parse, &l );
			parse_free( yypvt[-0].parse );
		} break;
d469 3
a471 2
# line 124 "jamgram.y"
{ yyval.parse = yypvt[-0].parse; } break;
d473 3
a475 2
# line 126 "jamgram.y"
{ yyval.parse = plocal( yypvt[-2].list, yypvt[-0].parse ); } break;
d477 3
a479 2
# line 130 "jamgram.y"
{ yyval.parse = prules( P0, P0 ); } break;
d481 3
a483 2
# line 132 "jamgram.y"
{ yyval.parse = prules( yypvt[-1].parse, yypvt[-0].parse ); } break;
d485 3
a487 2
# line 136 "jamgram.y"
{ yyval.parse = pincl( yypvt[-1].list ); } break;
d489 3
a491 2
# line 138 "jamgram.y"
{ yyval.parse = prule( yypvt[-2].string, yypvt[-1].parse ); } break;
d493 3
a495 2
# line 140 "jamgram.y"
{ yyval.parse = pset( yypvt[-3].list, yypvt[-1].list, yypvt[-2].number ); } break;
d497 3
a499 2
# line 142 "jamgram.y"
{ yyval.parse = pstng( yypvt[-3].list, yypvt[-5].list, yypvt[-1].list, yypvt[-2].number ); } break;
d501 3
a503 2
# line 144 "jamgram.y"
{ yyval.parse = pset( yypvt[-4].list, yypvt[-1].list, ASSIGN_DEFAULT ); } break;
d505 3
a507 2
# line 146 "jamgram.y"
{ yyval.parse = pfor( yypvt[-5].string, yypvt[-1].parse, yypvt[-3].list ); } break;
d509 3
a511 2
# line 148 "jamgram.y"
{ yyval.parse = pswitch( yypvt[-3].list, yypvt[-1].parse ); } break;
d513 3
a515 2
# line 150 "jamgram.y"
{ yyval.parse = pif( yypvt[-3].parse, pthen( yypvt[-1].parse, P0 ) ); } break;
d517 3
a519 2
# line 152 "jamgram.y"
{ yyval.parse = pif( yypvt[-5].parse, pthen( yypvt[-3].parse, yypvt[-0].parse ) ); } break;
d521 3
a523 2
# line 154 "jamgram.y"
{ yyval.parse = psetc( yypvt[-1].string, yypvt[-0].parse ); } break;
d525 3
a527 2
# line 156 "jamgram.y"
{ yymode( SCAN_STRING ); } break;
d529 4
a532 3
# line 158 "jamgram.y"
{ yyval.parse = psete( yypvt[-2].string, yypvt[-0].string, yypvt[-3].number );
		  yymode( SCAN_NORMAL ); } break;
d534 3
a536 2
# line 161 "jamgram.y"
{ yyval.parse = yypvt[-1].parse; } break;
d538 3
a540 2
# line 169 "jamgram.y"
{ yyval.number = ASSIGN_SET; } break;
d542 3
a544 2
# line 171 "jamgram.y"
{ yyval.number = ASSIGN_APPEND; } break;
d546 3
a548 2
# line 173 "jamgram.y"
{ yyval.number = ASSIGN_DEFAULT; } break;
d550 3
a552 2
# line 181 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yypvt[-0].list, L0 ); } break;
d554 3
a556 2
# line 183 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yypvt[-2].list, yypvt[-0].list ); } break;
d558 3
a560 2
# line 185 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d562 3
a564 2
# line 187 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yypvt[-2].list, yypvt[-0].list ); } break;
d566 3
a568 2
# line 189 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d570 3
a572 2
# line 191 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yypvt[-2].list, yypvt[-0].list ); } break;
d574 3
a576 2
# line 193 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d578 3
a580 2
# line 195 "jamgram.y"
{ yyval.parse = pcomp( COND_IN, yypvt[-2].list, yypvt[-0].list ); } break;
d582 3
a584 2
# line 197 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yypvt[-0].parse, P0 ); } break;
d586 3
a588 2
# line 199 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yypvt[-2].parse, yypvt[-0].parse ); } break;
d590 3
a592 2
# line 201 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yypvt[-2].parse, yypvt[-0].parse ); } break;
d594 3
a596 2
# line 203 "jamgram.y"
{ yyval.parse = yypvt[-1].parse; } break;
d598 3
a600 2
# line 214 "jamgram.y"
{ yyval.parse = P0; } break;
d602 3
a604 2
# line 216 "jamgram.y"
{ yyval.parse = pcases( yypvt[-1].parse, yypvt[-0].parse ); } break;
d606 3
a608 2
# line 220 "jamgram.y"
{ yyval.parse = pcase( yypvt[-2].string, yypvt[-0].parse ); } break;
d610 3
a612 2
# line 228 "jamgram.y"
{ yyval.parse = plol( P0, yypvt[-0].list ); } break;
d614 3
a616 2
# line 230 "jamgram.y"
{ yyval.parse = plol( yypvt[-0].parse, yypvt[-2].list ); } break;
d618 3
a620 2
# line 239 "jamgram.y"
{ yymode( SCAN_NORMAL ); } break;
d622 3
a624 2
# line 243 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); } break;
d626 3
a628 2
# line 245 "jamgram.y"
{ yyval.list = list_new( yypvt[-1].list, copystr( yypvt[-0].string ) ); } break;
d630 3
a632 2
# line 249 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yypvt[-0].string ) ); } break;
d634 3
a636 2
# line 258 "jamgram.y"
{ yyval.number = 0; } break;
d638 3
a640 2
# line 260 "jamgram.y"
{ yyval.number = yypvt[-1].number | yypvt[-0].number; } break;
d642 3
a644 2
# line 264 "jamgram.y"
{ yyval.number = EXEC_UPDATED; } break;
d646 3
a648 2
# line 266 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; } break;
d650 3
a652 2
# line 268 "jamgram.y"
{ yyval.number = EXEC_IGNORE; } break;
d654 3
a656 2
# line 270 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; } break;
d658 3
a660 2
# line 272 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; } break;
d662 59
a720 4
# line 274 "jamgram.y"
{ yyval.number = EXEC_EXISTING; } break;
	}
	goto yystack;		/* reset registers in driver code */
a721 1

@


1.10
log
@@
text
@a79 2
#include <values.h>

@


1.9
log
@@
text
@d1 39
a39 11
#ifndef lint
static char yysccsid[] = "@@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 63 "jamgram.y"
d55 1
a55 1
# define prule( s,l,r )   parse_make( compile_rule,P0,P0,s,S0,l,r,0 )
d69 1
d71 144
a214 166
#line 43 "y.tab.c"
#define _BANG 257
#define _BANG_EQUALS 258
#define _AMPERAMPER 259
#define _LPAREN 260
#define _RPAREN 261
#define _PLUS_EQUALS 262
#define _COLON 263
#define _SEMIC 264
#define _LANGLE 265
#define _LANGLE_EQUALS 266
#define _EQUALS 267
#define _RANGLE 268
#define _RANGLE_EQUALS 269
#define _QUESTION_EQUALS 270
#define ACTIONS 271
#define CASE 272
#define DEFAULT 273
#define ELSE 274
#define EXISTING 275
#define FOR 276
#define IF 277
#define IGNORE 278
#define IN 279
#define INCLUDE 280
#define LOCAL 281
#define ON 282
#define PIECEMEAL 283
#define QUIETLY 284
#define RULE 285
#define SWITCH 286
#define TOGETHER 287
#define UPDATED 288
#define _LBRACE 289
#define _BARBAR 290
#define _RBRACE 291
#define ARG 292
#define STRING 293
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    2,    2,    3,    3,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,   10,    1,    1,
    6,    6,    6,    8,    8,    8,    8,    8,    8,    8,
    8,    8,    8,    8,    8,    7,    7,   11,    4,   12,
   12,    5,    9,    9,   13,   13,   13,   13,   13,   13,
};
short yylen[] = {                                         2,
    0,    2,    1,    4,    0,    2,    3,    3,    5,    4,
    6,    5,    7,    5,    5,    7,    3,    0,    5,    3,
    1,    1,    1,    1,    3,    3,    3,    3,    3,    3,
    3,    2,    3,    3,    3,    0,    2,    4,    1,    0,
    2,    1,    0,    2,    1,    1,    1,    1,    1,    1,
};
short yydefred[] = {                                      1,
    0,   43,    0,    0,   40,    0,   40,    0,    0,    2,
    0,    0,    0,    0,    0,   42,    0,    0,    0,    0,
    0,    0,   40,    0,    0,    0,   22,   21,   23,    0,
   40,   40,   50,   47,   49,   48,   46,   45,   18,   44,
   40,   32,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    7,   41,   17,    0,    0,   20,    6,
   40,    8,   40,    0,    0,    0,    0,   35,   26,   27,
   28,   25,   29,   30,   31,   33,    0,    0,    0,    0,
    0,    5,    0,    0,   40,   10,   19,    0,    0,    0,
   14,   37,    0,    9,   12,    0,    0,    0,    0,   11,
   13,   16,   38,
};
short yydgoto[] = {                                       1,
   60,   24,   25,   19,   11,   32,   80,   18,   12,   66,
   81,   20,   40,
};
short yysindex[] = {                                      0,
 -147,    0, -280, -252,    0, -273,    0, -260,    0,    0,
 -136, -169, -255, -252, -252,    0, -118, -256, -234, -257,
 -147, -244,    0, -259, -147, -249,    0,    0,    0, -210,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -230, -227, -227, -227, -227, -227, -227, -227,
 -252, -260, -252,    0,    0,    0, -235, -195,    0,    0,
    0,    0,    0, -196, -192, -225, -214,    0,    0,    0,
    0,    0,    0,    0,    0,    0, -212, -176, -207, -205,
 -235,    0, -177, -175,    0,    0,    0, -260, -180, -170,
    0,    0, -147,    0,    0, -166, -203, -147, -260,    0,
    0,    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0, -164, -200,    0,
    0,    0,    0,    0,    0,    0, -248,    0,    0, -186,
    0,    0,    0,    0, -263,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0, -164,    0,    0,    0,    0, -191,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0, -251,    0,    0,
 -191,    0,    0,    0,    0,    0,    0, -164,    1,    0,
    0,    0, -247,    0,    0,    0,    0,    0, -181,    0,
    0,    0,    0,
};
short yygindex[] = {                                      0,
   -1,  -45,   19,   -5,    2,   38,   36,    8,    0,    0,
    0,    0,    0,
};
#define YYTABLESIZE 293
short yytable[] = {                                      10,
   15,   22,   51,   26,   14,   17,   77,   15,    3,   34,
   24,   13,   24,   61,   62,   17,   17,   58,   21,   56,
   23,   42,   43,   41,    4,   64,   65,    3,   51,   54,
   68,   59,   52,   53,   55,   67,   79,   34,   34,   16,
   24,   24,   97,    4,   57,   69,   70,   71,   72,   73,
   74,   75,   17,  103,   17,   83,   63,   84,   76,   53,
   78,   42,   40,   40,   16,   27,   42,   87,   82,   42,
   28,   86,   42,   29,   88,   39,   39,   39,   89,   96,
   39,   42,   51,   39,   90,   91,   94,  101,   95,    5,
    5,   40,   99,   98,    5,    5,  102,  100,    5,   36,
   93,   85,   39,    5,    5,   33,    5,    5,   34,    5,
    5,    5,    5,   35,   36,    5,   92,   37,   38,    0,
    5,    5,   39,    2,    5,   27,    5,    5,    3,    4,
   28,    0,    5,   29,    0,    0,   30,    6,    7,   44,
    0,    8,    0,    0,    9,   31,   45,   46,   47,   48,
   49,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   50,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   15,   15,    0,    0,    0,   15,   15,    0,    0,
   15,    0,    0,    0,    0,   15,   15,    0,    0,   15,
    0,   15,   15,
};
short yycheck[] = {                                       1,
    0,    7,  259,    9,  257,    4,   52,  260,  272,  261,
  259,  292,  261,  263,  264,   14,   15,   23,  292,   21,
  281,   14,   15,  279,  272,   31,   32,  291,  259,  264,
  261,  291,  289,  290,  292,   41,  272,  289,  290,  292,
  289,  290,   88,  291,  289,   44,   45,   46,   47,   48,
   49,   50,   51,   99,   53,   61,  267,   63,   51,  290,
   53,  262,  263,  264,  292,  262,  267,  293,  264,  270,
  267,  264,  273,  270,  289,  262,  263,  264,  291,   85,
  267,  282,  259,  270,  292,  291,  264,  291,  264,  271,
  272,  292,  263,  274,  276,  277,   98,  264,  280,  291,
   82,   64,  289,  285,  286,  275,  271,  289,  278,  291,
  292,  276,  277,  283,  284,  280,   81,  287,  288,   -1,
  285,  286,  292,  271,  289,  262,  291,  292,  276,  277,
  267,   -1,  280,  270,   -1,   -1,  273,  285,  286,  258,
   -1,  289,   -1,   -1,  292,  282,  265,  266,  267,  268,
  269,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  279,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  271,  272,   -1,   -1,   -1,  276,  277,   -1,   -1,
  280,   -1,   -1,   -1,   -1,  285,  286,   -1,   -1,  289,
   -1,  291,  292,
};
#define YYFINAL 1
d216 1
a216 1
#define YYDEBUG 0
d218 1
a218 1
#define YYMAXTOKEN 293
d220 41
a260 13
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_BANG","_BANG_EQUALS",
"_AMPERAMPER","_LPAREN","_RPAREN","_PLUS_EQUALS","_COLON","_SEMIC","_LANGLE",
"_LANGLE_EQUALS","_EQUALS","_RANGLE","_RANGLE_EQUALS","_QUESTION_EQUALS",
"ACTIONS","CASE","DEFAULT","ELSE","EXISTING","FOR","IF","IGNORE","IN","INCLUDE",
"LOCAL","ON","PIECEMEAL","QUIETLY","RULE","SWITCH","TOGETHER","UPDATED",
"_LBRACE","_BARBAR","_RBRACE","ARG","STRING",
d262 55
a316 52
char *yyrule[] = {
"$accept : stmts",
"stmts :",
"stmts : stmts rule",
"rules : rule0",
"rules : LOCAL args _SEMIC rule0",
"rule0 :",
"rule0 : rule0 rule",
"rule : INCLUDE args _SEMIC",
"rule : ARG args _SEMIC",
"rule : ARG args _COLON args _SEMIC",
"rule : arg1 assign args _SEMIC",
"rule : arg1 ON args assign args _SEMIC",
"rule : arg1 DEFAULT _EQUALS args _SEMIC",
"rule : FOR ARG IN args _LBRACE rules _RBRACE",
"rule : SWITCH args _LBRACE cases _RBRACE",
"rule : IF cond _LBRACE rules _RBRACE",
"rule : IF cond _LBRACE rules _RBRACE ELSE rule",
"rule : RULE ARG rule",
"$$1 :",
"rule : ACTIONS eflags ARG $$1 STRING",
"rule : _LBRACE rules _RBRACE",
"assign : _EQUALS",
"assign : _PLUS_EQUALS",
"assign : _QUESTION_EQUALS",
"cond : arg1",
"cond : arg1 _EQUALS arg1",
"cond : arg1 _BANG_EQUALS arg1",
"cond : arg1 _LANGLE arg1",
"cond : arg1 _LANGLE_EQUALS arg1",
"cond : arg1 _RANGLE arg1",
"cond : arg1 _RANGLE_EQUALS arg1",
"cond : arg1 IN arg1",
"cond : _BANG cond",
"cond : cond _AMPERAMPER cond",
"cond : cond _BARBAR cond",
"cond : _LPAREN cond _RPAREN",
"cases :",
"cases : case cases",
"case : CASE ARG _COLON rules",
"args : argsany",
"argsany :",
"argsany : argsany ARG",
"arg1 : ARG",
"eflags :",
"eflags : eflags eflag",
"eflag : UPDATED",
"eflag : TOGETHER",
"eflag : IGNORE",
"eflag : QUIETLY",
"eflag : PIECEMEAL",
"eflag : EXISTING",
d318 37
a354 3
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
d356 35
a390 6
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
d392 1
a392 2
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
d394 38
a432 17
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
d434 1
a434 4
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();
d436 12
a447 6
    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
d450 10
a459 3
    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);
d461 10
a470 3
    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;
d472 33
a504 5
yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
d506 60
a565 8
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
d567 20
a586 4
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
d588 4
a591 28
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
yynewerror:
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
d593 2
a594 11
yyerrlab:
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
d596 36
a631 14
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
d633 1
a633 3
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
d635 2
a636 9
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
d638 95
a732 8
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
d734 9
a742 4
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
d744 52
a795 3
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
d797 53
a849 4
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
d851 1
a851 1
#line 102 "jamgram.y"
d854 1
a854 2
		}
break;
d856 1
a856 1
#line 106 "jamgram.y"
d858 8
a865 4
			(*(yyvsp[0].parse->func))( yyvsp[0].parse, L0, L0 );
			parse_free( yyvsp[0].parse );
		}
break;
d867 2
a868 3
#line 118 "jamgram.y"
{ yyval.parse = yyvsp[0].parse; }
break;
d870 2
a871 3
#line 120 "jamgram.y"
{ yyval.parse = plocal( yyvsp[-2].list, yyvsp[0].parse ); }
break;
d873 2
a874 3
#line 124 "jamgram.y"
{ yyval.parse = prules( P0, P0 ); }
break;
d876 2
a877 3
#line 126 "jamgram.y"
{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
break;
d879 2
a880 3
#line 130 "jamgram.y"
{ yyval.parse = pincl( yyvsp[-1].list ); }
break;
d882 2
a883 3
#line 132 "jamgram.y"
{ yyval.parse = prule( yyvsp[-2].string, yyvsp[-1].list, L0 ); }
break;
d885 2
a886 3
#line 134 "jamgram.y"
{ yyval.parse = prule( yyvsp[-4].string, yyvsp[-3].list, yyvsp[-1].list ); }
break;
d888 2
a889 3
#line 136 "jamgram.y"
{ yyval.parse = pset( yyvsp[-3].list, yyvsp[-1].list, yyvsp[-2].number ); }
break;
d891 2
a892 3
#line 138 "jamgram.y"
{ yyval.parse = pstng( yyvsp[-3].list, yyvsp[-5].list, yyvsp[-1].list, yyvsp[-2].number ); }
break;
d894 2
a895 3
#line 140 "jamgram.y"
{ yyval.parse = pset( yyvsp[-4].list, yyvsp[-1].list, ASSIGN_DEFAULT ); }
break;
d897 2
a898 3
#line 142 "jamgram.y"
{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-1].parse, yyvsp[-3].list ); }
break;
d900 2
a901 3
#line 144 "jamgram.y"
{ yyval.parse = pswitch( yyvsp[-3].list, yyvsp[-1].parse ); }
break;
d903 2
a904 3
#line 146 "jamgram.y"
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, P0 ) ); }
break;
d906 2
a907 3
#line 148 "jamgram.y"
{ yyval.parse = pif( yyvsp[-5].parse, pthen( yyvsp[-3].parse, yyvsp[0].parse ) ); }
break;
d909 2
a910 3
#line 150 "jamgram.y"
{ yyval.parse = psetc( yyvsp[-1].string, yyvsp[0].parse ); }
break;
d912 3
a914 3
#line 152 "jamgram.y"
{ yymode( SCAN_STRING ); }
break;
d916 2
a917 4
#line 154 "jamgram.y"
{ yyval.parse = psete( yyvsp[-2].string, yyvsp[0].string, yyvsp[-3].number );
		  yymode( SCAN_NORMAL ); }
break;
d919 2
a920 3
#line 157 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
break;
d922 2
a923 3
#line 165 "jamgram.y"
{ yyval.number = ASSIGN_SET; }
break;
d925 2
a926 3
#line 167 "jamgram.y"
{ yyval.number = ASSIGN_APPEND; }
break;
d928 2
a929 3
#line 169 "jamgram.y"
{ yyval.number = ASSIGN_DEFAULT; }
break;
d931 2
a932 3
#line 177 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yyvsp[0].list, L0 ); }
break;
d934 2
a935 3
#line 179 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yyvsp[-2].list, yyvsp[0].list ); }
break;
d937 2
a938 3
#line 181 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
d940 2
a941 3
#line 183 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yyvsp[-2].list, yyvsp[0].list ); }
break;
d943 2
a944 3
#line 185 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
d946 2
a947 3
#line 187 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yyvsp[-2].list, yyvsp[0].list ); }
break;
d949 2
a950 3
#line 189 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yyvsp[-2].list, yyvsp[0].list ); }
break;
d952 2
a953 3
#line 191 "jamgram.y"
{ yyval.parse = pcomp( COND_IN, yyvsp[-2].list, yyvsp[0].list ); }
break;
d955 2
a956 3
#line 193 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yyvsp[0].parse, P0 ); }
break;
d958 2
a959 3
#line 195 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
break;
d961 2
a962 3
#line 197 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
break;
d964 2
a965 3
#line 199 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
break;
d967 2
a968 3
#line 210 "jamgram.y"
{ yyval.parse = P0; }
break;
d970 2
a971 3
#line 212 "jamgram.y"
{ yyval.parse = pcases( yyvsp[-1].parse, yyvsp[0].parse ); }
break;
d973 2
a974 3
#line 216 "jamgram.y"
{ yyval.parse = pcase( yyvsp[-2].string, yyvsp[0].parse ); }
break;
d976 2
a977 3
#line 225 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
break;
d979 2
a980 3
#line 229 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); }
break;
d982 2
a983 3
#line 231 "jamgram.y"
{ yyval.list = list_new( yyvsp[-1].list, copystr( yyvsp[0].string ) ); }
break;
d985 2
a986 3
#line 235 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yyvsp[0].string ) ); }
break;
d988 2
a989 3
#line 244 "jamgram.y"
{ yyval.number = 0; }
break;
d991 2
a992 3
#line 246 "jamgram.y"
{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
break;
d994 2
a995 3
#line 250 "jamgram.y"
{ yyval.number = EXEC_UPDATED; }
break;
d997 2
a998 3
#line 252 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; }
break;
d1000 2
a1001 3
#line 254 "jamgram.y"
{ yyval.number = EXEC_IGNORE; }
break;
d1003 2
a1004 3
#line 256 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; }
break;
d1006 2
a1007 3
#line 258 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; }
break;
d1009 7
a1015 59
#line 260 "jamgram.y"
{ yyval.number = EXEC_EXISTING; }
break;
#line 653 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
d1017 1
@


1.7
log
@@
text
@@


1.6
log
@@
text
@d11 1
a11 1
#line 62 "jamgram.y"
d34 1
d42 1
a42 1
#line 42 "y.tab.c"
d67 13
a79 12
#define ON 281
#define PIECEMEAL 282
#define QUIETLY 283
#define RULE 284
#define SWITCH 285
#define TOGETHER 286
#define UPDATED 287
#define _LBRACE 288
#define _BARBAR 289
#define _RBRACE 290
#define ARG 291
#define STRING 292
d82 5
a86 5
    0,    0,    2,    2,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    9,    1,    1,    5,    5,
    5,    7,    7,    7,    7,    7,    7,    7,    7,    7,
    7,    7,    6,    6,   10,    3,   11,   11,    4,    8,
    8,   12,   12,   12,   12,   12,   12,
d89 5
a93 5
    0,    2,    0,    2,    3,    3,    5,    4,    6,    5,
    7,    5,    5,    7,    3,    0,    5,    3,    1,    1,
    1,    1,    3,    3,    3,    3,    3,    3,    2,    3,
    3,    3,    0,    2,    4,    1,    0,    2,    1,    0,
    2,    1,    1,    1,    1,    1,    1,
d96 11
a106 10
    0,   40,    0,    0,   37,    0,   37,    3,    0,    2,
    0,    0,    0,    0,    0,   39,    0,    0,    0,    0,
    0,    0,    0,    0,   20,   19,   21,    0,   37,   37,
   47,   44,   46,   45,   43,   42,   16,   41,   37,   29,
    0,    0,    0,    0,    0,    0,    0,    0,    3,    0,
    5,   38,   15,    0,   18,    4,   37,    6,   37,    0,
    0,    0,    0,   32,   24,   25,   26,   23,   27,   28,
   30,    0,    0,    0,    0,    0,    0,    0,   37,    8,
   17,    3,    0,    0,   12,   34,    7,   10,    0,    0,
    0,    3,    9,   11,   14,    0,
d109 2
a110 2
   56,   23,   19,   11,   30,   75,   18,   12,   62,   76,
   20,   38,
d113 3
a115 3
 -141,    0, -281, -249,    0, -278,    0,    0,    0,    0,
 -125, -129, -264, -249, -249,    0,  -99, -256, -243, -272,
 -141, -265, -191, -202,    0,    0,    0, -240,    0,    0,
d117 7
a123 6
 -233, -262, -262, -262, -262, -262, -262, -249,    0, -249,
    0,    0,    0, -241,    0,    0,    0,    0,    0, -194,
 -229, -254, -248,    0,    0,    0,    0,    0,    0,    0,
    0, -173, -195, -234, -223, -241, -185, -183,    0,    0,
    0,    0, -190, -181,    0,    0,    0,    0, -176, -157,
 -141,    0,    0,    0,    0, -141,
d126 3
a128 3
    0,    0,    0,    0,    0,    0,    0,    0, -204,    0,
    0,    0,    0,    0,    0,    0, -245,    0,    0, -192,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
d131 1
a131 1
    0,    0,    0, -207,    0,    0,    0,    0,    0,    0,
d133 4
a136 3
    0,    0, -252,    0,    0, -207,    0,    0,    0,    0,
    0,    0,    1,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -260,
d139 2
a140 2
   -1,  -27,   -5,    3,   31,   16,   -9,    0,    0,    0,
    0,    0,
d142 1
a142 1
#define YYTABLESIZE 292
d144 17
a160 17
   13,   22,   48,   24,   40,   41,   17,   14,   31,   13,
   15,   35,   21,   22,   39,   22,   17,   17,   52,   53,
   51,   72,   54,   60,   61,   48,   59,   64,   16,   35,
   74,   49,   50,   63,   80,   31,   31,   81,   71,   82,
   73,   16,   22,   22,   65,   66,   67,   68,   69,   70,
   17,   77,   17,   78,   90,   50,   84,   39,   37,   37,
   57,   58,   39,   48,   96,   39,   85,   25,   39,   36,
   36,   36,   26,   89,   36,   27,   39,   36,   87,    2,
   88,   92,   33,   91,    3,    4,   37,   93,    5,   95,
   79,   86,    6,    7,    0,   36,    8,    2,   55,    9,
    0,    0,    3,    4,    0,    0,    5,    0,    0,    0,
    6,    7,    0,    2,    8,    0,   83,    9,    3,    4,
    0,    0,    5,    0,    0,    0,    6,    7,    0,    2,
    8,    0,   94,    9,    3,    4,   25,    0,    5,    0,
    0,   26,    6,    7,   27,   31,    8,   28,   32,    9,
    0,    0,   33,   34,    0,   29,   35,   36,   42,    0,
    0,   37,    0,    0,    0,   43,   44,   45,   46,   47,
d171 3
a173 3
    0,   13,   13,    0,    0,    0,   13,   13,    0,    0,
   13,    0,    0,    0,   13,   13,    0,    0,   13,    0,
   13,   13,
d176 17
a192 17
    0,    7,  259,    9,   14,   15,    4,  257,  261,  291,
  260,  272,  291,  259,  279,  261,   14,   15,  291,   21,
  264,   49,  288,   29,   30,  259,  267,  261,  291,  290,
  272,  288,  289,   39,  264,  288,  289,  292,   48,  288,
   50,  291,  288,  289,   42,   43,   44,   45,   46,   47,
   48,   57,   50,   59,   82,  289,  291,  262,  263,  264,
  263,  264,  267,  259,   92,  270,  290,  262,  273,  262,
  263,  264,  267,   79,  267,  270,  281,  270,  264,  271,
  264,  263,  290,  274,  276,  277,  291,  264,  280,   91,
   60,   76,  284,  285,   -1,  288,  288,  271,  290,  291,
   -1,   -1,  276,  277,   -1,   -1,  280,   -1,   -1,   -1,
  284,  285,   -1,  271,  288,   -1,  290,  291,  276,  277,
   -1,   -1,  280,   -1,   -1,   -1,  284,  285,   -1,  271,
  288,   -1,  290,  291,  276,  277,  262,   -1,  280,   -1,
   -1,  267,  284,  285,  270,  275,  288,  273,  278,  291,
   -1,   -1,  282,  283,   -1,  281,  286,  287,  258,   -1,
   -1,  291,   -1,   -1,   -1,  265,  266,  267,  268,  269,
d204 2
a205 2
  280,   -1,   -1,   -1,  284,  285,   -1,   -1,  288,   -1,
  290,  291,
d211 1
a211 1
#define YYMAXTOKEN 292
d224 2
a225 2
"ON","PIECEMEAL","QUIETLY","RULE","SWITCH","TOGETHER","UPDATED","_LBRACE",
"_BARBAR","_RBRACE","ARG","STRING",
d231 4
a234 2
"rules :",
"rules : rules rule",
d259 1
d447 1
a447 1
#line 100 "jamgram.y"
d453 1
a453 1
#line 104 "jamgram.y"
d460 2
a461 2
#line 116 "jamgram.y"
{ yyval.parse = prules( P0, P0 ); }
d464 2
a465 2
#line 118 "jamgram.y"
{ yyval.parse = prules( yyvsp[-1].parse, yyvsp[0].parse ); }
d468 2
a469 2
#line 122 "jamgram.y"
{ yyval.parse = pincl( yyvsp[-1].list ); }
d472 2
a473 2
#line 124 "jamgram.y"
{ yyval.parse = prule( yyvsp[-2].string, yyvsp[-1].list, L0 ); }
d476 2
a477 2
#line 126 "jamgram.y"
{ yyval.parse = prule( yyvsp[-4].string, yyvsp[-3].list, yyvsp[-1].list ); }
d480 2
a481 2
#line 128 "jamgram.y"
{ yyval.parse = pset( yyvsp[-3].list, yyvsp[-1].list, yyvsp[-2].number ); }
d484 2
a485 2
#line 130 "jamgram.y"
{ yyval.parse = pstng( yyvsp[-3].list, yyvsp[-5].list, yyvsp[-1].list, yyvsp[-2].number ); }
d488 2
a489 2
#line 132 "jamgram.y"
{ yyval.parse = pset( yyvsp[-4].list, yyvsp[-1].list, ASSIGN_DEFAULT ); }
d492 2
a493 2
#line 134 "jamgram.y"
{ yyval.parse = pfor( yyvsp[-5].string, yyvsp[-1].parse, yyvsp[-3].list ); }
d496 2
a497 2
#line 136 "jamgram.y"
{ yyval.parse = pswitch( yyvsp[-3].list, yyvsp[-1].parse ); }
d500 2
a501 2
#line 138 "jamgram.y"
{ yyval.parse = pif( yyvsp[-3].parse, pthen( yyvsp[-1].parse, P0 ) ); }
d504 2
a505 2
#line 140 "jamgram.y"
{ yyval.parse = pif( yyvsp[-5].parse, pthen( yyvsp[-3].parse, yyvsp[0].parse ) ); }
d508 2
a509 2
#line 142 "jamgram.y"
{ yyval.parse = psetc( yyvsp[-1].string, yyvsp[0].parse ); }
d512 2
a513 2
#line 144 "jamgram.y"
{ yymode( SCAN_STRING ); }
d516 2
a517 3
#line 146 "jamgram.y"
{ yyval.parse = psete( yyvsp[-2].string, yyvsp[0].string, yyvsp[-3].number );
		  yymode( SCAN_NORMAL ); }
d520 2
a521 2
#line 149 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
d524 3
a526 2
#line 157 "jamgram.y"
{ yyval.number = ASSIGN_SET; }
d529 2
a530 2
#line 159 "jamgram.y"
{ yyval.number = ASSIGN_APPEND; }
d533 2
a534 2
#line 161 "jamgram.y"
{ yyval.number = ASSIGN_DEFAULT; }
d537 2
a538 2
#line 169 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yyvsp[0].list, L0 ); }
d541 2
a542 2
#line 171 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yyvsp[-2].list, yyvsp[0].list ); }
d545 2
a546 2
#line 173 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yyvsp[-2].list, yyvsp[0].list ); }
d549 2
a550 2
#line 175 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yyvsp[-2].list, yyvsp[0].list ); }
d553 2
a554 2
#line 177 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yyvsp[-2].list, yyvsp[0].list ); }
d557 2
a558 2
#line 179 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yyvsp[-2].list, yyvsp[0].list ); }
d561 2
a562 2
#line 181 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yyvsp[-2].list, yyvsp[0].list ); }
d565 2
a566 2
#line 183 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yyvsp[0].parse, P0 ); }
d569 2
a570 2
#line 185 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yyvsp[-2].parse, yyvsp[0].parse ); }
d573 2
a574 2
#line 187 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yyvsp[-2].parse, yyvsp[0].parse ); }
d577 2
a578 2
#line 189 "jamgram.y"
{ yyval.parse = yyvsp[-1].parse; }
d581 2
a582 2
#line 200 "jamgram.y"
{ yyval.parse = P0; }
d585 2
a586 2
#line 202 "jamgram.y"
{ yyval.parse = pcases( yyvsp[-1].parse, yyvsp[0].parse ); }
d589 2
a590 2
#line 206 "jamgram.y"
{ yyval.parse = pcase( yyvsp[-2].string, yyvsp[0].parse ); }
d593 2
a594 2
#line 215 "jamgram.y"
{ yymode( SCAN_NORMAL ); }
d597 2
a598 2
#line 219 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); }
d601 2
a602 2
#line 221 "jamgram.y"
{ yyval.list = list_new( yyvsp[-1].list, copystr( yyvsp[0].string ) ); }
d606 1
a606 1
{ yyval.list = list_new( L0, copystr( yyvsp[0].string ) ); }
d609 2
a610 2
#line 234 "jamgram.y"
{ yyval.number = 0; }
d613 2
a614 2
#line 236 "jamgram.y"
{ yyval.number = yyvsp[-1].number | yyvsp[0].number; }
d617 2
a618 2
#line 240 "jamgram.y"
{ yyval.number = EXEC_UPDATED; }
d621 2
a622 2
#line 242 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; }
d625 2
a626 2
#line 244 "jamgram.y"
{ yyval.number = EXEC_IGNORE; }
d629 2
a630 2
#line 246 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; }
d633 2
a634 2
#line 248 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; }
d637 13
a649 1
#line 250 "jamgram.y"
d652 1
a652 1
#line 633 "y.tab.c"
@


1.5
log
@@
text
@d1 11
a11 39
extern char *malloc(), *realloc();
# define _BANG 257
# define _BANG_EQUALS 258
# define _AMPERAMPER 259
# define _LPAREN 260
# define _RPAREN 261
# define _PLUS_EQUALS 262
# define _COLON 263
# define _SEMIC 264
# define _LANGLE 265
# define _LANGLE_EQUALS 266
# define _EQUALS 267
# define _RANGLE 268
# define _RANGLE_EQUALS 269
# define _QUESTION_EQUALS 270
# define ACTIONS 271
# define CASE 272
# define DEFAULT 273
# define ELSE 274
# define EXISTING 275
# define FOR 276
# define IF 277
# define IGNORE 278
# define IN 279
# define INCLUDE 280
# define ON 281
# define PIECEMEAL 282
# define QUIETLY 283
# define RULE 284
# define SWITCH 285
# define TOGETHER 286
# define UPDATED 287
# define _LBRACE 288
# define _BARBAR 289
# define _RBRACE 290
# define ARG 291
# define STRING 292

# line 62 "jamgram.y"
d41 162
a202 99
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256
int yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 4,
	263, 37,
	264, 37,
	291, 37,
	-2, 39,
	};
# define YYNPROD 48
# define YYLAST 173
int yyact[]={

    10,    89,    87,    27,    32,     6,     8,    28,    25,     3,
    21,    26,    85,     9,     7,    84,    10,    11,    39,    94,
     4,     6,     8,    38,    93,     3,    41,    69,    79,     9,
     7,    37,    10,    11,    90,    88,     4,     6,     8,    34,
    33,     3,    27,    41,    83,     9,     7,    81,    10,    11,
    63,    61,     4,     6,     8,    31,    42,     3,    92,    19,
    41,     9,     7,    59,    18,    11,    56,    20,     4,    30,
    58,    57,    40,    42,    55,    54,    19,    67,    60,    52,
     2,    18,    44,    53,    20,    15,    13,    17,    68,    45,
    46,    43,    47,    48,     5,    16,    12,    80,    29,     1,
     0,    14,    23,    24,    22,     0,     0,    51,     0,     0,
    70,     0,    35,    36,     0,     0,     0,     0,     0,     0,
    24,    24,    64,     0,     0,     0,     0,     0,    49,    50,
     0,    62,     0,     0,    65,    66,    24,    24,    73,    74,
    75,    76,    77,    78,    71,    72,    86,     0,     0,     0,
     0,     0,     0,     0,    91,     0,     0,     0,     0,     0,
     0,    82,    95,     0,     0,     0,     0,     0,     0,     0,
     0,     0,    96 };
int yypact[]={

 -1000,  -223, -1000, -1000, -1000,  -186,  -281, -1000,  -249,  -284,
 -1000, -1000,  -209,  -287,  -224, -1000, -1000,  -236, -1000, -1000,
 -1000,  -256,  -270,  -216,  -176,  -249,  -249, -1000,  -223,  -212,
  -239, -1000, -1000, -1000, -1000,  -214,  -203, -1000, -1000,  -245,
 -1000,  -249,  -249,  -288,  -288,  -288,  -288,  -288,  -288, -1000,
  -233, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000, -1000,  -217, -1000, -1000,  -220,  -273,  -278,  -245,  -289,
  -255, -1000,  -199, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
  -291, -1000,  -230, -1000, -1000, -1000, -1000,  -205,  -250, -1000,
 -1000,  -271, -1000,  -223, -1000,  -223, -1000 };
int yypgo[]={

     0,    99,    78,    69,    96,    94,    85,    77,   102,    98,
    97,    88,    86,    83 };
int yyr1[]={

     0,     1,     1,     3,     3,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    10,     2,     2,     6,
     6,     6,     8,     8,     8,     8,     8,     8,     8,     8,
     8,     8,     8,     7,     7,    11,     4,    12,    12,     5,
     9,     9,    13,    13,    13,    13,    13,    13 };
int yyr2[]={

     0,     1,     5,     1,     5,     7,     7,    11,     9,    13,
    11,    15,    11,    11,    15,     7,     1,    11,     7,     3,
     3,     3,     3,     7,     7,     7,     7,     7,     7,     5,
     7,     7,     7,     1,     5,     9,     3,     1,     5,     3,
     1,     5,     3,     3,     3,     3,     3,     3 };
int yychk[]={

 -1000,    -1,    -2,   280,   291,    -5,   276,   285,   277,   284,
   271,   288,    -4,   -12,    -4,    -6,   281,   273,   267,   262,
   270,   291,    -4,    -8,    -5,   257,   260,   291,   291,    -9,
    -3,   264,   291,   264,   263,    -4,    -4,   267,   279,   288,
   288,   259,   289,   267,   258,   265,   266,   268,   269,    -8,
    -8,    -2,   291,   -13,   287,   286,   278,   283,   282,   275,
    -2,   290,    -4,   264,    -6,    -4,    -4,    -7,   -11,   272,
    -3,    -8,    -8,    -5,    -5,    -5,    -5,    -5,    -5,   261,
   -10,   264,    -4,   264,   288,   290,    -7,   291,   290,   292,
   264,    -3,   263,   274,   290,    -3,    -2 };
int yydef[]={

     1,    -2,     2,    37,    -2,     0,     0,    37,     0,     0,
    40,     3,     0,    36,     0,    37,    37,     0,    19,    20,
    21,     0,     0,     0,    22,     0,     0,    39,     0,     0,
     0,     5,    38,     6,    37,     0,     0,    37,    37,    33,
     3,     0,     0,     0,     0,     0,     0,     0,     0,    29,
     0,    15,    16,    41,    42,    43,    44,    45,    46,    47,
     4,    18,     0,     8,    37,     0,     0,     0,    33,     0,
     0,    30,    31,    23,    24,    25,    26,    27,    28,    32,
     0,     7,     0,    10,     3,    12,    34,     0,    13,    17,
     9,     0,     3,     0,    11,    35,    14 };
typedef struct { char *t_name; int t_val; } yytoktype;
d204 1
a204 1
#	define YYDEBUG	0	/* don't allow debugging */
d206 1
a206 1

d208 13
a220 40

yytoktype yytoks[] =
{
	"_BANG",	257,
	"_BANG_EQUALS",	258,
	"_AMPERAMPER",	259,
	"_LPAREN",	260,
	"_RPAREN",	261,
	"_PLUS_EQUALS",	262,
	"_COLON",	263,
	"_SEMIC",	264,
	"_LANGLE",	265,
	"_LANGLE_EQUALS",	266,
	"_EQUALS",	267,
	"_RANGLE",	268,
	"_RANGLE_EQUALS",	269,
	"_QUESTION_EQUALS",	270,
	"ACTIONS",	271,
	"CASE",	272,
	"DEFAULT",	273,
	"ELSE",	274,
	"EXISTING",	275,
	"FOR",	276,
	"IF",	277,
	"IGNORE",	278,
	"IN",	279,
	"INCLUDE",	280,
	"ON",	281,
	"PIECEMEAL",	282,
	"QUIETLY",	283,
	"RULE",	284,
	"SWITCH",	285,
	"TOGETHER",	286,
	"UPDATED",	287,
	"_LBRACE",	288,
	"_BARBAR",	289,
	"_RBRACE",	290,
	"ARG",	291,
	"STRING",	292,
	"-unknown-",	-1	/* ends search */
d222 49
a270 51

char * yyreds[] =
{
	"-no such reduction-",
	"stmts : /* empty */",
	"stmts : stmts rule",
	"rules : /* empty */",
	"rules : rules rule",
	"rule : INCLUDE args _SEMIC",
	"rule : ARG args _SEMIC",
	"rule : ARG args _COLON args _SEMIC",
	"rule : arg1 assign args _SEMIC",
	"rule : arg1 ON args assign args _SEMIC",
	"rule : arg1 DEFAULT _EQUALS args _SEMIC",
	"rule : FOR ARG IN args _LBRACE rules _RBRACE",
	"rule : SWITCH args _LBRACE cases _RBRACE",
	"rule : IF cond _LBRACE rules _RBRACE",
	"rule : IF cond _LBRACE rules _RBRACE ELSE rule",
	"rule : RULE ARG rule",
	"rule : ACTIONS eflags ARG",
	"rule : ACTIONS eflags ARG STRING",
	"rule : _LBRACE rules _RBRACE",
	"assign : _EQUALS",
	"assign : _PLUS_EQUALS",
	"assign : _QUESTION_EQUALS",
	"cond : arg1",
	"cond : arg1 _EQUALS arg1",
	"cond : arg1 _BANG_EQUALS arg1",
	"cond : arg1 _LANGLE arg1",
	"cond : arg1 _LANGLE_EQUALS arg1",
	"cond : arg1 _RANGLE arg1",
	"cond : arg1 _RANGLE_EQUALS arg1",
	"cond : _BANG cond",
	"cond : cond _AMPERAMPER cond",
	"cond : cond _BARBAR cond",
	"cond : _LPAREN cond _RPAREN",
	"cases : /* empty */",
	"cases : case cases",
	"case : CASE ARG _COLON rules",
	"args : argsany",
	"argsany : /* empty */",
	"argsany : argsany ARG",
	"arg1 : ARG",
	"eflags : /* empty */",
	"eflags : eflags eflag",
	"eflag : UPDATED",
	"eflag : TOGETHER",
	"eflag : IGNORE",
	"eflag : QUIETLY",
	"eflag : PIECEMEAL",
	"eflag : EXISTING",
a271 29
#endif /* YYDEBUG */
#line 1 "/usr/lib/yaccpar"
/*	@@(#)yaccpar 1.10 89/04/04 SMI; from S5R3 1.10	*/

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	{ free(yys); free(yyv); return(0); }
#define YYABORT		{ free(yys); free(yyv); return(1); }
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( "syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
d273 29
a301 32

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-1000)

/*
** static variables used by the parser
*/
static YYSTYPE *yyv;			/* value stack */
static int *yys;			/* state stack */

static YYSTYPE *yypv;			/* top of value stack */
static int *yyps;			/* top of state stack */

static int yystate;			/* current state */
static int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */

int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */


/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
d305 4
a308 37
	register YYSTYPE *yypvt;	/* top of value stack for $vars */
	unsigned yymaxdepth = YYMAXDEPTH;

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yyv = (YYSTYPE*)malloc(yymaxdepth*sizeof(YYSTYPE));
	yys = (int*)malloc(yymaxdepth*sizeof(int));
	if (!yyv || !yys)
	{
		yyerror( "out of memory" );
		return(1);
	}
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;
d310 7
a316 8
		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
d318 3
a320 17
		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;
d322 3
a324 42
			(void)printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			int yyps_index = (yy_ps - yys);
			int yypv_index = (yy_pv - yyv);
			int yypvt_index = (yypvt - yyv);
			yymaxdepth += YYMAXDEPTH;
			yyv = (YYSTYPE*)realloc((char*)yyv,
				yymaxdepth * sizeof(YYSTYPE));
			yys = (int*)realloc((char*)yys,
				yymaxdepth * sizeof(int));
			if (!yyv || !yys)
			{
				yyerror( "yacc stack overflow" );
				return(1);
			}
			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;
d326 5
a330 6
		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
d332 8
a339 4
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
d341 4
a344 39
		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			(void)printf( "Received token " );
			if ( yychar == 0 )
				(void)printf( "end-of-file\n" );
			else if ( yychar < 0 )
				(void)printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				(void)printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
d346 3
a348 1
			yytmp = yychar < 0;
d350 36
a385 2
			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
				yychar = 0;		/* reached EOF */
d387 14
a400 88
			if ( yydebug && yytmp )
			{
				register int yy_i;

				(void)printf( "Received token " );
				if ( yychar == 0 )
					(void)printf( "end-of-file\n" );
				else if ( yychar < 0 )
					(void)printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					(void)printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror( "syntax error" );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
				yynerrs++;
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
d402 3
a404 5
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						(void)printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
d406 9
a414 9
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
d416 13
a428 43
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					(void)printf( "Error recovery discards " );
					if ( yychar == 0 )
						(void)printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						(void)printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						(void)printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
d430 3
a432 8
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			(void)printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
d434 4
a437 53
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
d439 1
a439 1
# line 100 "jamgram.y"
d442 2
a443 1
		} break;
d445 1
a445 1
# line 104 "jamgram.y"
d447 4
a450 3
			(*(yypvt[-0].parse->func))( yypvt[-0].parse, L0, L0 );
			parse_free( yypvt[-0].parse );
		} break;
d452 3
a454 2
# line 116 "jamgram.y"
{ yyval.parse = prules( P0, P0 ); } break;
d456 3
a458 2
# line 118 "jamgram.y"
{ yyval.parse = prules( yypvt[-1].parse, yypvt[-0].parse ); } break;
d460 3
a462 2
# line 122 "jamgram.y"
{ yyval.parse = pincl( yypvt[-1].list ); } break;
d464 3
a466 2
# line 124 "jamgram.y"
{ yyval.parse = prule( yypvt[-2].string, yypvt[-1].list, L0 ); } break;
d468 3
a470 2
# line 126 "jamgram.y"
{ yyval.parse = prule( yypvt[-4].string, yypvt[-3].list, yypvt[-1].list ); } break;
d472 3
a474 2
# line 128 "jamgram.y"
{ yyval.parse = pset( yypvt[-3].list, yypvt[-1].list, yypvt[-2].number ); } break;
d476 3
a478 2
# line 130 "jamgram.y"
{ yyval.parse = pstng( yypvt[-3].list, yypvt[-5].list, yypvt[-1].list, yypvt[-2].number ); } break;
d480 3
a482 2
# line 132 "jamgram.y"
{ yyval.parse = pset( yypvt[-4].list, yypvt[-1].list, ASSIGN_DEFAULT ); } break;
d484 3
a486 2
# line 134 "jamgram.y"
{ yyval.parse = pfor( yypvt[-5].string, yypvt[-1].parse, yypvt[-3].list ); } break;
d488 3
a490 2
# line 136 "jamgram.y"
{ yyval.parse = pswitch( yypvt[-3].list, yypvt[-1].parse ); } break;
d492 3
a494 2
# line 138 "jamgram.y"
{ yyval.parse = pif( yypvt[-3].parse, pthen( yypvt[-1].parse, P0 ) ); } break;
d496 3
a498 2
# line 140 "jamgram.y"
{ yyval.parse = pif( yypvt[-5].parse, pthen( yypvt[-3].parse, yypvt[-0].parse ) ); } break;
d500 3
a502 2
# line 142 "jamgram.y"
{ yyval.parse = psetc( yypvt[-1].string, yypvt[-0].parse ); } break;
d504 3
a506 2
# line 144 "jamgram.y"
{ yymode( SCAN_STRING ); } break;
d508 4
a511 3
# line 146 "jamgram.y"
{ yyval.parse = psete( yypvt[-2].string, yypvt[-0].string, yypvt[-3].number );
		  yymode( SCAN_NORMAL ); } break;
d513 3
a515 2
# line 149 "jamgram.y"
{ yyval.parse = yypvt[-1].parse; } break;
d517 3
a519 2
# line 157 "jamgram.y"
{ yyval.number = ASSIGN_SET; } break;
d521 3
a523 2
# line 159 "jamgram.y"
{ yyval.number = ASSIGN_APPEND; } break;
d525 3
a527 2
# line 161 "jamgram.y"
{ yyval.number = ASSIGN_DEFAULT; } break;
d529 3
a531 2
# line 169 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yypvt[-0].list, L0 ); } break;
d533 3
a535 2
# line 171 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yypvt[-2].list, yypvt[-0].list ); } break;
d537 3
a539 2
# line 173 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d541 3
a543 2
# line 175 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yypvt[-2].list, yypvt[-0].list ); } break;
d545 3
a547 2
# line 177 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d549 3
a551 2
# line 179 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yypvt[-2].list, yypvt[-0].list ); } break;
d553 3
a555 2
# line 181 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d557 3
a559 2
# line 183 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yypvt[-0].parse, P0 ); } break;
d561 3
a563 2
# line 185 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yypvt[-2].parse, yypvt[-0].parse ); } break;
d565 3
a567 2
# line 187 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yypvt[-2].parse, yypvt[-0].parse ); } break;
d569 3
a571 2
# line 189 "jamgram.y"
{ yyval.parse = yypvt[-1].parse; } break;
d573 3
a575 2
# line 200 "jamgram.y"
{ yyval.parse = P0; } break;
d577 3
a579 2
# line 202 "jamgram.y"
{ yyval.parse = pcases( yypvt[-1].parse, yypvt[-0].parse ); } break;
d581 3
a583 2
# line 206 "jamgram.y"
{ yyval.parse = pcase( yypvt[-2].string, yypvt[-0].parse ); } break;
d585 3
a587 2
# line 215 "jamgram.y"
{ yymode( SCAN_NORMAL ); } break;
d589 3
a591 2
# line 219 "jamgram.y"
{ yyval.list = L0; yymode( SCAN_PUNCT ); } break;
d593 3
a595 2
# line 221 "jamgram.y"
{ yyval.list = list_new( yypvt[-1].list, copystr( yypvt[-0].string ) ); } break;
d597 3
a599 2
# line 225 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yypvt[-0].string ) ); } break;
d601 3
a603 2
# line 234 "jamgram.y"
{ yyval.number = 0; } break;
d605 3
a607 2
# line 236 "jamgram.y"
{ yyval.number = yypvt[-1].number | yypvt[-0].number; } break;
d609 3
a611 2
# line 240 "jamgram.y"
{ yyval.number = EXEC_UPDATED; } break;
d613 3
a615 2
# line 242 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; } break;
d617 3
a619 2
# line 244 "jamgram.y"
{ yyval.number = EXEC_IGNORE; } break;
d621 3
a623 2
# line 246 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; } break;
d625 3
a627 2
# line 248 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; } break;
d629 59
a687 4
# line 250 "jamgram.y"
{ yyval.number = EXEC_EXISTING; } break;
	}
	goto yystack;		/* reset registers in driver code */
@


1.4
log
@@
text
@d40 2
d708 1
a708 1
# line 98 "jamgram.y"
d713 1
a713 1
# line 102 "jamgram.y"
d719 1
a719 1
# line 114 "jamgram.y"
d722 1
a722 1
# line 116 "jamgram.y"
d725 1
a725 1
# line 120 "jamgram.y"
d728 1
a728 1
# line 122 "jamgram.y"
d731 1
a731 1
# line 124 "jamgram.y"
d734 1
a734 1
# line 126 "jamgram.y"
d737 1
a737 1
# line 128 "jamgram.y"
d740 1
a740 1
# line 130 "jamgram.y"
d743 1
a743 1
# line 132 "jamgram.y"
d746 1
a746 1
# line 134 "jamgram.y"
d749 1
a749 1
# line 136 "jamgram.y"
d752 1
a752 1
# line 138 "jamgram.y"
d755 1
a755 1
# line 140 "jamgram.y"
d758 1
a758 1
# line 142 "jamgram.y"
d761 1
a761 1
# line 144 "jamgram.y"
d765 1
a765 1
# line 147 "jamgram.y"
d768 1
a768 1
# line 155 "jamgram.y"
d771 1
a771 1
# line 157 "jamgram.y"
d774 1
a774 1
# line 159 "jamgram.y"
d777 1
a777 1
# line 167 "jamgram.y"
d780 1
a780 1
# line 169 "jamgram.y"
d783 1
a783 1
# line 171 "jamgram.y"
d786 1
a786 1
# line 173 "jamgram.y"
d789 1
a789 1
# line 175 "jamgram.y"
d792 1
a792 1
# line 177 "jamgram.y"
d795 1
a795 1
# line 179 "jamgram.y"
d798 1
a798 1
# line 181 "jamgram.y"
d801 1
a801 1
# line 183 "jamgram.y"
d804 1
a804 1
# line 185 "jamgram.y"
d807 1
a807 1
# line 187 "jamgram.y"
d810 1
a810 1
# line 198 "jamgram.y"
d813 1
a813 1
# line 200 "jamgram.y"
d816 1
a816 1
# line 204 "jamgram.y"
d819 1
a819 1
# line 213 "jamgram.y"
d822 1
a822 1
# line 217 "jamgram.y"
d825 1
a825 1
# line 219 "jamgram.y"
d828 1
a828 1
# line 223 "jamgram.y"
d831 1
a831 1
# line 232 "jamgram.y"
d834 1
a834 1
# line 234 "jamgram.y"
d837 1
a837 1
# line 238 "jamgram.y"
d840 1
a840 1
# line 240 "jamgram.y"
d843 1
a843 1
# line 242 "jamgram.y"
d846 1
a846 1
# line 244 "jamgram.y"
d849 1
a849 1
# line 246 "jamgram.y"
d852 1
a852 1
# line 248 "jamgram.y"
@


1.3
log
@@
text
@d39 1
a39 1
# line 59 "jamgram.y"
d84 4
a87 4
	263, 36,
	264, 36,
	291, 36,
	-2, 38,
d89 2
a90 2
# define YYNPROD 47
# define YYLAST 181
d93 18
a110 19
    10,    88,    18,    86,    26,     6,     8,    17,    24,     3,
    19,    25,    89,     9,     7,    83,    10,    11,    31,    93,
     4,     6,     8,    82,    27,     3,    20,    33,    32,     9,
     7,    31,    10,    11,    84,    87,     4,     6,     8,    31,
    80,     3,    26,    40,    38,     9,     7,    31,    10,    11,
    31,    60,     4,     6,     8,    31,    62,     3,    30,    37,
    92,     9,     7,    58,    91,    11,    55,    31,     4,    68,
    57,    56,    39,    41,    54,    53,    40,    36,    78,    51,
    40,    18,    59,    31,     2,    31,    17,    43,    29,    19,
    66,    52,    16,    14,    44,    45,    42,    46,    47,    12,
    15,    22,    67,    79,    13,    28,    41,    21,     1,     5,
    50,     0,     0,     0,    34,    35,     0,     0,    23,     0,
     0,     0,     0,     0,     0,     0,    48,    49,    69,    63,
     0,     0,     0,    61,    23,    23,    64,    65,     0,     0,
     0,     0,    70,    71,     0,     0,     0,     0,     0,     0,
    23,    23,    72,    73,    74,    75,    76,    77,    85,     0,
     0,     0,     0,    81,     0,     0,     0,     0,     0,     0,
     0,     0,    90,     0,     0,    95,     0,     0,     0,     0,
    94 };
d113 10
a122 10
 -1000,  -223, -1000, -1000, -1000,  -181,  -265, -1000,  -249,  -267,
 -1000, -1000,  -206,  -236, -1000, -1000,  -190, -1000, -1000, -1000,
  -220,  -244,  -216,  -171,  -249,  -249, -1000,  -223,  -212,  -239,
 -1000, -1000, -1000, -1000,  -208,  -260, -1000, -1000,  -203, -1000,
  -249,  -249,  -287,  -287,  -287,  -287,  -287,  -287, -1000,  -183,
 -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
 -1000,  -224, -1000, -1000,  -241,  -273,  -256,  -203,  -288,  -255,
 -1000,  -179, -1000, -1000, -1000, -1000, -1000, -1000, -1000,  -291,
 -1000,  -252, -1000, -1000, -1000, -1000,  -199,  -214, -1000, -1000,
  -271, -1000,  -223, -1000,  -223, -1000 };
d125 2
a126 2
     0,   108,    82,    88,    99,   109,    93,    90,   101,   105,
   103,   102,    91 };
d132 2
a133 2
     8,     8,     8,     7,     7,    11,     4,     4,     5,     9,
     9,    12,    12,    12,    12,    12,    12 };
d139 2
a140 2
     7,     7,     7,     1,     5,     9,     1,     5,     3,     1,
     5,     3,     3,     3,     3,     3,     3 };
d144 9
a152 9
   271,   288,    -4,    -4,    -6,   281,   273,   267,   262,   270,
   291,    -4,    -8,    -5,   257,   260,   291,   291,    -9,    -3,
   264,   291,   264,   263,    -4,    -4,   267,   279,   288,   288,
   259,   289,   267,   258,   265,   266,   268,   269,    -8,    -8,
    -2,   291,   -12,   287,   286,   278,   283,   282,   275,    -2,
   290,    -4,   264,    -6,    -4,    -4,    -7,   -11,   272,    -3,
    -8,    -8,    -5,    -5,    -5,    -5,    -5,    -5,   261,   -10,
   264,    -4,   264,   288,   290,    -7,   291,   290,   292,   264,
    -3,   263,   274,   290,    -3,    -2 };
d155 10
a164 10
     1,    -2,     2,    36,    -2,     0,     0,    36,     0,     0,
    39,     3,     0,     0,    36,    36,     0,    19,    20,    21,
     0,     0,     0,    22,     0,     0,    38,     0,     0,     0,
     5,    37,     6,    36,     0,     0,    36,    36,    33,     3,
     0,     0,     0,     0,     0,     0,     0,     0,    29,     0,
    15,    16,    40,    41,    42,    43,    44,    45,    46,     4,
    18,     0,     8,    36,     0,     0,     0,    33,     0,     0,
    30,    31,    23,    24,    25,    26,    27,    28,    32,     0,
     7,     0,    10,     3,    12,    34,     0,    13,    17,     9,
     0,     3,     0,    11,    35,    14 };
d251 3
a253 2
	"args : /* empty */",
	"args : args ARG",
d706 1
a706 1
# line 95 "jamgram.y"
d711 1
a711 1
# line 99 "jamgram.y"
d717 1
a717 1
# line 111 "jamgram.y"
d720 1
a720 1
# line 113 "jamgram.y"
d723 1
a723 1
# line 117 "jamgram.y"
d726 1
a726 1
# line 119 "jamgram.y"
d729 1
a729 1
# line 121 "jamgram.y"
d732 1
a732 1
# line 123 "jamgram.y"
d735 1
a735 1
# line 125 "jamgram.y"
d738 1
a738 1
# line 127 "jamgram.y"
d741 1
a741 1
# line 129 "jamgram.y"
d744 1
a744 1
# line 131 "jamgram.y"
d747 1
a747 1
# line 133 "jamgram.y"
d750 1
a750 1
# line 135 "jamgram.y"
d753 1
a753 1
# line 137 "jamgram.y"
d756 2
a757 2
# line 139 "jamgram.y"
{ scan_asstring = 1; } break;
d759 1
a759 1
# line 141 "jamgram.y"
d761 1
a761 1
		  scan_asstring = 0; } break;
d763 1
a763 1
# line 144 "jamgram.y"
d766 1
a766 1
# line 152 "jamgram.y"
d769 1
a769 1
# line 154 "jamgram.y"
d772 1
a772 1
# line 156 "jamgram.y"
d775 1
a775 1
# line 164 "jamgram.y"
d778 1
a778 1
# line 166 "jamgram.y"
d781 1
a781 1
# line 168 "jamgram.y"
d784 1
a784 1
# line 170 "jamgram.y"
d787 1
a787 1
# line 172 "jamgram.y"
d790 1
a790 1
# line 174 "jamgram.y"
d793 1
a793 1
# line 176 "jamgram.y"
d796 1
a796 1
# line 178 "jamgram.y"
d799 1
a799 1
# line 180 "jamgram.y"
d802 1
a802 1
# line 182 "jamgram.y"
d805 1
a805 1
# line 184 "jamgram.y"
d808 1
a808 1
# line 195 "jamgram.y"
d811 1
a811 1
# line 197 "jamgram.y"
d814 1
a814 1
# line 201 "jamgram.y"
d817 2
a818 2
# line 210 "jamgram.y"
{ yyval.list = L0; } break;
d820 2
a821 2
# line 212 "jamgram.y"
{ yyval.list = list_new( yypvt[-1].list, copystr( yypvt[-0].string ) ); } break;
d823 2
a824 2
# line 216 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yypvt[-0].string ) ); } break;
d826 2
a827 2
# line 225 "jamgram.y"
{ yyval.number = 0; } break;
d829 2
a830 2
# line 227 "jamgram.y"
{ yyval.number = yypvt[-1].number | yypvt[-0].number; } break;
d832 2
a833 2
# line 231 "jamgram.y"
{ yyval.number = EXEC_UPDATED; } break;
d835 2
a836 2
# line 233 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; } break;
d838 2
a839 2
# line 235 "jamgram.y"
{ yyval.number = EXEC_IGNORE; } break;
d841 2
a842 2
# line 237 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; } break;
d844 2
a845 2
# line 239 "jamgram.y"
{ yyval.number = EXEC_PIECEMEAL; } break;
d847 4
a850 1
# line 241 "jamgram.y"
@


1.2
log
@@
text
@d39 1
a39 1
# line 57 "jamgram.y"
d706 1
a706 1
# line 93 "jamgram.y"
d711 1
a711 1
# line 97 "jamgram.y"
d717 1
a717 1
# line 109 "jamgram.y"
d720 1
a720 1
# line 111 "jamgram.y"
d723 1
a723 1
# line 115 "jamgram.y"
d726 1
a726 1
# line 117 "jamgram.y"
d729 1
a729 1
# line 119 "jamgram.y"
d732 1
a732 1
# line 121 "jamgram.y"
d735 1
a735 1
# line 123 "jamgram.y"
d738 1
a738 1
# line 125 "jamgram.y"
d741 1
a741 1
# line 127 "jamgram.y"
d744 1
a744 1
# line 129 "jamgram.y"
d747 1
a747 1
# line 131 "jamgram.y"
d750 1
a750 1
# line 133 "jamgram.y"
d753 1
a753 1
# line 135 "jamgram.y"
d756 1
a756 1
# line 137 "jamgram.y"
d759 1
a759 1
# line 139 "jamgram.y"
d763 1
a763 1
# line 142 "jamgram.y"
d766 1
a766 1
# line 150 "jamgram.y"
d769 1
a769 1
# line 152 "jamgram.y"
d772 1
a772 1
# line 154 "jamgram.y"
d775 1
a775 1
# line 162 "jamgram.y"
d778 1
a778 1
# line 164 "jamgram.y"
d781 1
a781 1
# line 166 "jamgram.y"
d784 1
a784 1
# line 168 "jamgram.y"
d787 1
a787 1
# line 170 "jamgram.y"
d790 1
a790 1
# line 172 "jamgram.y"
d793 1
a793 1
# line 174 "jamgram.y"
d796 1
a796 1
# line 176 "jamgram.y"
d799 1
a799 1
# line 178 "jamgram.y"
d802 1
a802 1
# line 180 "jamgram.y"
d805 1
a805 1
# line 182 "jamgram.y"
d808 1
a808 1
# line 193 "jamgram.y"
d811 1
a811 1
# line 195 "jamgram.y"
d814 1
a814 1
# line 199 "jamgram.y"
d817 1
a817 1
# line 208 "jamgram.y"
d820 1
a820 1
# line 210 "jamgram.y"
d823 1
a823 1
# line 214 "jamgram.y"
d826 1
a826 1
# line 223 "jamgram.y"
d829 1
a829 1
# line 225 "jamgram.y"
d832 1
a832 1
# line 229 "jamgram.y"
d835 1
a835 1
# line 231 "jamgram.y"
d838 1
a838 1
# line 233 "jamgram.y"
d841 1
a841 1
# line 235 "jamgram.y"
d844 1
a844 1
# line 237 "jamgram.y"
d847 1
a847 1
# line 239 "jamgram.y"
@


1.1
log
@@
text
@d7 31
a37 28
# define _COLON 262
# define _SEMIC 263
# define _LANGLE 264
# define _LANGLE_EQUALS 265
# define _EQUALS 266
# define _RANGLE 267
# define _RANGLE_EQUALS 268
# define ACTIONS 269
# define CASE 270
# define DEFAULT 271
# define ELSE 272
# define FOR 273
# define IF 274
# define IGNORE 275
# define IN 276
# define INCLUDE 277
# define ON 278
# define PIECEMEAL 279
# define QUIETLY 280
# define RULE 281
# define SWITCH 282
# define TOGETHER 283
# define UPDATED 284
# define _LBRACE 285
# define _BARBAR 286
# define _RBRACE 287
# define ARG 288
# define STRING 289
d39 1
a39 1
# line 47 "jamgram.y"
a47 1
# define L0 (LIST *)0
d50 3
a52 4
# define pset( l,r ) 	  parse_make( compile_set,P0,P0,S0,S0,l,r,0 )
# define psettings( l,p ) parse_make( compile_settings,p,P0,S0,S0,l,L0,0 )
# define pseton( l,r ) 	  parse_make( F0,P0,P0,S0,S0,l,r,0 )
# define psetdef( l,r )   parse_make( compile_setdefault,P0,P0,S0,S0,l,r,0 )
d84 4
a87 4
	266, 35,
	271, 35,
	278, 35,
	-2, 33,
d89 2
a90 2
# define YYNPROD 43
# define YYLAST 177
d93 19
a111 18
    10,    84,    51,    83,     6,     8,    53,    52,     3,    27,
    50,    49,     9,     7,    81,    47,    11,    10,    88,     4,
    76,     6,     8,    29,    28,     3,    27,    23,    78,     9,
     7,    27,    75,    11,    10,    82,     4,    17,     6,     8,
    59,    57,     3,    26,    33,    27,     9,     7,    87,    27,
    11,    10,    55,     4,    36,     6,     8,    27,    34,     3,
    31,    27,    27,     9,     7,    39,    27,    11,    27,    63,
     4,    40,    41,    38,    42,    43,    36,    79,    73,    14,
    35,    37,    86,    21,    15,    25,    22,    36,    54,    48,
     2,    16,    20,    61,    62,    27,    12,    13,    74,    24,
    18,     5,     1,    37,     0,    19,     0,    30,     0,    32,
     0,     0,    46,     0,     0,     0,     0,     0,     0,     0,
     0,    64,    56,     0,    58,     0,    60,    44,    45,     0,
     0,    67,    68,    69,    70,    71,    72,     0,     0,     0,
     0,     0,    65,    66,     0,     0,     0,     0,     0,     0,
     0,     0,    77,     0,     0,     0,    80,     0,     0,     0,
     0,     0,     0,     0,    85,     0,     0,     0,     0,     0,
     0,     0,    89,     0,     0,     0,    90 };
d114 10
a123 10
 -1000,  -218, -1000, -1000, -1000,  -187,  -251, -1000,  -174,  -261,
 -1000, -1000,  -220,  -239, -1000,  -206, -1000,  -232,  -227,  -205,
  -193,  -174,  -174,  -218,  -273,  -235, -1000, -1000, -1000, -1000,
  -222, -1000,  -226, -1000,  -201, -1000,  -174,  -174, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000,  -183, -1000, -1000, -1000, -1000,
 -1000, -1000, -1000, -1000, -1000, -1000,  -231, -1000,  -243, -1000,
  -257,  -210,  -201,  -274,  -252, -1000,  -172,  -279,  -279,  -279,
  -279,  -279,  -279, -1000,  -286, -1000, -1000,  -262, -1000, -1000,
 -1000,  -180,  -224, -1000, -1000,  -269, -1000,  -218, -1000,  -218,
 -1000 };
d126 2
a127 2
     0,   102,    88,    85,    92,   101,    93,   105,    99,    98,
    94,    89 };
d131 4
a134 4
     2,     2,     2,     2,     2,     2,     9,     2,     2,     7,
     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
     6,     6,    10,     4,     4,     5,     8,     8,    11,    11,
    11,    11,    11 };
d137 5
a141 5
     0,     1,     5,     1,     5,     7,     7,    11,     9,    11,
    13,    15,    11,    11,    15,     7,     1,    11,     7,     3,
     7,     7,     7,     7,     7,     7,     5,     7,     7,     7,
     1,     5,     9,     1,     5,     3,     1,     5,     3,     3,
     3,     3,     3 };
d144 10
a153 10
 -1000,    -1,    -2,   277,   288,    -5,   273,   282,   274,   281,
   269,   285,    -4,    -4,   266,   271,   278,   288,    -4,    -7,
    -4,   257,   260,   288,    -8,    -3,   263,   288,   263,   262,
    -4,   266,    -4,   276,   285,   285,   259,   286,   266,   258,
   264,   265,   267,   268,    -7,    -7,    -2,   288,   -11,   284,
   283,   275,   280,   279,    -2,   287,    -4,   263,    -4,   266,
    -4,    -6,   -10,   270,    -3,    -7,    -7,    -4,    -4,    -4,
    -4,    -4,    -4,   261,    -9,   263,   263,    -4,   285,   287,
    -6,   288,   287,   289,   263,    -3,   262,   272,   287,    -3,
    -2 };
d156 10
a165 10
     1,    -2,     2,    33,    -2,     0,     0,    33,    33,     0,
    36,     3,     0,     0,    33,     0,    33,     0,     0,     0,
    19,    33,    33,     0,     0,     0,     5,    34,     6,    33,
     0,    33,     0,    33,    30,     3,    33,    33,    33,    33,
    33,    33,    33,    33,    26,     0,    15,    16,    37,    38,
    39,    40,    41,    42,     4,    18,     0,     8,     0,    33,
     0,     0,    30,     0,     0,    27,    28,    20,    21,    22,
    23,    24,    25,    29,     0,     7,     9,     0,     3,    12,
    31,     0,    13,    17,    10,     0,     3,     0,    11,    32,
    14 };
d180 31
a210 28
	"_COLON",	262,
	"_SEMIC",	263,
	"_LANGLE",	264,
	"_LANGLE_EQUALS",	265,
	"_EQUALS",	266,
	"_RANGLE",	267,
	"_RANGLE_EQUALS",	268,
	"ACTIONS",	269,
	"CASE",	270,
	"DEFAULT",	271,
	"ELSE",	272,
	"FOR",	273,
	"IF",	274,
	"IGNORE",	275,
	"IN",	276,
	"INCLUDE",	277,
	"ON",	278,
	"PIECEMEAL",	279,
	"QUIETLY",	280,
	"RULE",	281,
	"SWITCH",	282,
	"TOGETHER",	283,
	"UPDATED",	284,
	"_LBRACE",	285,
	"_BARBAR",	286,
	"_RBRACE",	287,
	"ARG",	288,
	"STRING",	289,
d224 2
a225 1
	"rule : arg1 _EQUALS args _SEMIC",
a226 1
	"rule : arg1 ON args _EQUALS args _SEMIC",
d235 10
a244 7
	"cond : args",
	"cond : args _EQUALS args",
	"cond : args _BANG_EQUALS args",
	"cond : args _LANGLE args",
	"cond : args _LANGLE_EQUALS args",
	"cond : args _RANGLE args",
	"cond : args _RANGLE_EQUALS args",
d262 1
d706 1
a706 1
# line 85 "jamgram.y"
d711 1
a711 1
# line 89 "jamgram.y"
d717 1
a717 1
# line 101 "jamgram.y"
d720 1
a720 1
# line 103 "jamgram.y"
d723 1
a723 1
# line 107 "jamgram.y"
d726 1
a726 1
# line 109 "jamgram.y"
d729 1
a729 1
# line 111 "jamgram.y"
d732 2
a733 2
# line 113 "jamgram.y"
{ yyval.parse = pset( yypvt[-3].list, yypvt[-1].list ); } break;
d735 2
a736 2
# line 115 "jamgram.y"
{ yyval.parse = psetdef( yypvt[-4].list, yypvt[-1].list ); } break;
d738 2
a739 2
# line 117 "jamgram.y"
{ yyval.parse = psettings( yypvt[-3].list, pseton( yypvt[-5].list, yypvt[-1].list ) ); } break;
d741 1
a741 1
# line 119 "jamgram.y"
d744 1
a744 1
# line 121 "jamgram.y"
d747 1
a747 1
# line 123 "jamgram.y"
d750 1
a750 1
# line 125 "jamgram.y"
d753 1
a753 1
# line 127 "jamgram.y"
d756 1
a756 1
# line 129 "jamgram.y"
d759 1
a759 1
# line 131 "jamgram.y"
d763 1
a763 1
# line 134 "jamgram.y"
d766 2
a767 2
# line 142 "jamgram.y"
{ yyval.parse = pcomp( COND_EXISTS, yypvt[-0].list, L0 ); } break;
d769 2
a770 2
# line 144 "jamgram.y"
{ yyval.parse = pcomp( COND_EQUALS, yypvt[-2].list, yypvt[-0].list ); } break;
d772 2
a773 2
# line 146 "jamgram.y"
{ yyval.parse = pcomp( COND_NOTEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d775 2
a776 2
# line 148 "jamgram.y"
{ yyval.parse = pcomp( COND_LESS, yypvt[-2].list, yypvt[-0].list ); } break;
d778 2
a779 2
# line 150 "jamgram.y"
{ yyval.parse = pcomp( COND_LESSEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d781 2
a782 2
# line 152 "jamgram.y"
{ yyval.parse = pcomp( COND_MORE, yypvt[-2].list, yypvt[-0].list ); } break;
d784 2
a785 2
# line 154 "jamgram.y"
{ yyval.parse = pcomp( COND_MOREEQ, yypvt[-2].list, yypvt[-0].list ); } break;
d787 2
a788 2
# line 156 "jamgram.y"
{ yyval.parse = pcond( COND_NOT, yypvt[-0].parse, P0 ); } break;
d790 2
a791 2
# line 158 "jamgram.y"
{ yyval.parse = pcond( COND_AND, yypvt[-2].parse, yypvt[-0].parse ); } break;
d793 2
a794 2
# line 160 "jamgram.y"
{ yyval.parse = pcond( COND_OR, yypvt[-2].parse, yypvt[-0].parse ); } break;
d796 2
a797 2
# line 162 "jamgram.y"
{ yyval.parse = yypvt[-1].parse; } break;
d799 2
a800 2
# line 173 "jamgram.y"
{ yyval.parse = P0; } break;
d802 2
a803 2
# line 175 "jamgram.y"
{ yyval.parse = pcases( yypvt[-1].parse, yypvt[-0].parse ); } break;
d805 2
a806 2
# line 179 "jamgram.y"
{ yyval.parse = pcase( yypvt[-2].string, yypvt[-0].parse ); } break;
d808 2
a809 2
# line 188 "jamgram.y"
{ yyval.list = L0; } break;
d811 2
a812 2
# line 190 "jamgram.y"
{ yyval.list = list_new( yypvt[-1].list, copystr( yypvt[-0].string ) ); } break;
d814 2
a815 2
# line 194 "jamgram.y"
{ yyval.list = list_new( L0, copystr( yypvt[-0].string ) ); } break;
d817 2
a818 2
# line 203 "jamgram.y"
{ yyval.number = 0; } break;
d820 2
a821 2
# line 205 "jamgram.y"
{ yyval.number = yypvt[-1].number | yypvt[-0].number; } break;
d823 2
a824 2
# line 209 "jamgram.y"
{ yyval.number = EXEC_UPDATED; } break;
d826 2
a827 2
# line 211 "jamgram.y"
{ yyval.number = EXEC_TOGETHER; } break;
d829 2
a830 2
# line 213 "jamgram.y"
{ yyval.number = EXEC_IGNORE; } break;
d832 2
a833 2
# line 215 "jamgram.y"
{ yyval.number = EXEC_QUIETLY; } break;
d835 10
a844 1
# line 217 "jamgram.y"
d846 3
@
